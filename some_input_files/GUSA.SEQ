;******************************************************************************
;*									      *	
;*									      *	
;*	PROGRAM NAME:	SYS$SYSDEVICE:[D3DATA.PCM0.SABL]GUSA.SEQ	      *
;*									      *
;*									      *	
;*									      *
;*	PROJECT NAME:	MILLER BREWING, TRENTON, OH  			      *	
;*	PROJECT NUM :							      *
;*	PCM NUMBER  :	PCM0						      *
;*	WRITTEN BY  :	LYNN GRIFFIN					      *
;*									      *	
;*	DATE	    :	DECEMBER 8, 1992				      *
;*									      *
;*									      *
;*									      *
;*	MODIFICATION LOG						      *	
;*									      *
;*									      *
;*	NO.	DATE	INITIALS	DESCRIPTION			      *
;*	--	----	--------	-----------			      *	
;*	1	4/22/93	MLB001		Added code to FAIL so that all devices*
;*					are shut off.  Added lines to CLOSDEV *
;*					and CLOSDEV3 to allow continuation of *
;*					FAIL.  Got rid of CLOSDEV & changed   *
;*					the former CLOSDEV2 to CLOSDEV.       *
;*					Included second RETCLR in CLOSDEV2.   *
;*     						   			      *
;*     									      *
;*	2	4/28/93 KAN002		ADDED SA MESSAGE AND FLASHING SKID    *
;*     					FOR 8101LH441 PIT HOPPER              *
;*	3	4/30/93	KAN003		REMOVED THE T_26 CHANGE IN OPENDEV    *
;*					AND CLOSDEV			      *
;	4	5/19/93 MLB002		ADDED CHECK OF 8101SS51,52,53,&10 FOR *
;					FAULT STATUS			      *
;	5	5/19/93	MLB004		clear SA_MSG when 8101lh441 not high  *
;	6	5/19/93	MLB006		added 2 second wait and recheck of the*
;					seal device to help assure it's truly *
;					faulted				      *
;	7	5/27/93	MLB007		sa message and flashing skid were lit *
;					for the wrong situation.  Moved       *
;					changes previously done by kan002 &   *
;					mlb004                                *
;	8	6/1/93	MLB008		added WAIT 1 before goto gu3ss        *
;	9	6/1/93	MLB009		added WAIT 1 in fail state for the    *
;					instance when 8101do1 is in $S0       *
;					immediately which would let           *
;					the program go right back to the      *
;					gu state like a continuous loop       *
;					and could consequently issue a lot of *
;					lamp commands in 1 sec--bogs the      *
;					system                                *
;      10	6/3/93	MLB010		Added logic to handle holding of gusa *
;      11	6/9/93	MLB011		Added sa_msgs to ESTOP 1, restored    *
;					setting of T24 bit in FAIL routine    *
;      12	6/18/93	MLB012		added ERSCLR before WAITUNTIL(0) in errsub, 
;					added SA_MSG in errsub, added exit 
;					after WAITUNTIL(0), added HRSCLR to 
;					HOLDSUB
;      13	7/27/93	KAN004		ADDED EPN FOR DUST COLLECTOR HI LVL*
;      14	9/16/93	KAN005		ADDED RETURNCLEAR IN CLOSDEV*
;      15	10/7/93	DWM001		Added PRINT statements for state
;					transtions
;      16	11/19/93 DWM002		Commented out setting of $T3 bit in
;					CLOSDEV3 routine.  This should only be
;					set for 8101RF4 and 8101XV51 in the 
;					OPENDEV3 routine.  It is cleared prior
;					to calling CLOSDEV3 for 8101RF4 and
;					8101XV51 (shared devices).
;*     17	12/06/94 VCM001		ADDED WAIT TO START 8101K4 AFTER INTLK*
;*     					FROM 8101LH441			      *
;*     18	29/AUG/95 VCM002        CHANGED GOSUB ESTOP STATEMENTS TO
;*     					GOTO ESTOP AND ADDED RETCLRs IN 
;                                       ESTOP LABELS
;      19	02/OCT/95 VCM003	ADDED AUTO_SHUTDN FLAG TO ALLOW TECH	
;                                       TO KEEP SYSTEM RUNNING BETWEEN CARS
;      20	02/OCT/95 VCM004	ADDED GU6 STATE TO RUN SPECIALTY
;                                       MALT DEVICES DAILY TO PREVENT
;                                       MECHANICAL LOCKUP FROM INFREQUENT USE
;      21       24/JAN/96 VCM005        DON'T START IF 8101Z1DS DIV SEAL IN
;                                       OVERRIDE
;      22	22/MAR/96 VCM006	CLEAR GRAIN WEIGHT VARIABLES IN IDLE
;                                       AND WAITING
;      23	04/MAY/01 VCM007	Check diverter position
; 					switches for more than one made
;      24       30/JUL/01 JFH000        ALLOW HOPPER TO EMPTY FOR 5 MIN
;      25	28-FEB-02 VCM008	Comment out 8101c72, using plant air	
;	26 	10-MAY-08 VCM009 	comment out 8101xv51
;*	27	08/22/08  VCM010	Comment out 8101C101, using plant air 
;	28	11-24-2008 MRP001	ADDED GU DUST BLOWER 8101C33
;	29 	12-17-08		mrp002	added cleaner timer and plant air solenoid
;	30	12-21-08		mrp003	remove 8101sr101 from logic cleaner drive replaced by solenoid valves 
;	31	07-JAN-09 KER000 COMMENT OUT 8101SR41, 8101C22 as per ICC
;	32 	19-JAN-09 KER000	programming grits to malt conversion 
;	33	21-JAN-09 KER001	TEMP. SECONDS
;	34	2-JAN-09  KER002	added the skel include file
;					added sc_sa_start_cmd and sc_sa_off_cmd
;	35	5-JAN-09  KER???	need to verify with site engineering
;	36	9-feb-09  adm000	added the constants.h include file
;	37	9-feb-09  adm001	added the Grunld_Epn.h include file
;	38	9-feb-09  adm002	added the grunld_upf.h include file
;	39	26-feb-09 gmp001	Updates
;	40	26-Feb-09 gmp002	Per Mark Huffman - Start 8101C33 at startup
;  41 16-MAR-09 VCM011  8101C22 STILL EXISTS  - UNCOMMENT - ADD DUST_COLLECTOR_USE_PLANT_AIR
;	42 27-OCT-2010	MRP004	NOT ALLOW SILO 4 BECAUSE OF X BLEND
;	43	10 nov 10	mrp005	special malt now uses malt dust collector
;	44	13-dec-10 ajw000	replace references to 8101RF7 with 8101RF4, 8101C71 to 8101C41
;	                                replace references to 8101SR71 with 8101SR41, 8101LSH71 to 8101LSH41
;					removed ref to 8101XV71 as M7 & M8 no longer use these devices
;	45	13-dec-2010	ldk000	Replace cleaner drive SR41 with PVT41, turnon silo dust
;					collector airlock purge 8101SV4
;	46	19-dec-2010	ldk001	Removed 8101C22 - Buhler removed, but was not on 
;					original removals list
;	47	20-dec-2010	ajw001	Add differential pressure checks for dust collectors
;	48	17-SEP-2013	VCM012	Added extra cleanout time for black and carmel malt and check rail put message
;	49	24-FEB-2014	VCM013	Changes to unload any malt type to any malt silo by matching silo grain
;									type unloading grain type.
;	50	06-JUN-2014	VCM014	Print PT41 reading while unloading
;  51	27-MAY-2015 VCM015	When starting RF41 put ouput in vfd 8101fc41
;  52 26-APR-2016 JMS001   Added wait time for grain unloading pit clean out during start up
;  53 23-JAN-2018 JMS002   Cleaned up messaging for out of range DP on unloading blower
;  54	10-APR-2018 PBH001	Changed wording for pt41
;  55 30-APR-2018 JMS003   Added print statement for 8101PT81
;	56 27-AUG-2018 PBH002	Added chocholate and caramel 10/30 blend malts for Killians
;******************************************************************************
;
;
;
;	PROGRAM FUNCTION:	This program performs the sequence
;                               administration for Grains Unloading (GU).
;
;
;
;
;
;	SUBROUTINES REFERENCED:		
;	----------------------
;
;
;	       	SUBROUTINE	DESCRIPTION
;		~~~~~~~~~~	~~~~~~~~~~~
;
;		1.  ERRSUB	PROGRAM RUN-TIME ERRORS
;		2.  OPENDEV	OPENS DEVICES, CHECKING FOR ERRORS
;		3.  OPENDEV3	OPENS 8101RF4 OR 8101XV51, CHECKING FOR ERRORS
;		4.  CLOSDEV	CLOSES DEVICES WHICH MAY BE CLOSED THROUGH
;		       		OTHER CLOSE SUBROUTINES
;		5.  CLOSDEV3	CLOSES 8101RF4 OR 8101XV51, CHECKING FOR ERRORS
;               6.  ESTOP1	GOES TO ESTOP (ESTOP TYPE = 1)
;		7.  ESTOP2      GOES TO ESTOP (ESTOP TYPE = 2)
;		8.  C8101K4	STOPS CONVEYOR 8101K4
;	        9.  C8101RF41	STOPS 8101RF41
;              10.  C101C102    STOPS 8101C102
;	       11.  C101C101    STOPS 8101C101
;	       12.  C8101SR101  STOPS 8101SR101
;	       13.  C8101RF1   	STOPS 8101RF1
;	       14.  C8101C12 	STOPS 8101C12
;	       15.  CFAN	STOPS DUSTCOLL_FAN_PTR
;	       16.  CBLOWER	STOPS PRGE_BLOWR_PTR
;	       17.  CDRIVE	STOPS CLNR_DRV_PTR
;	       18.  CAIRLOCK	STOPS DUST_AIRLOCK_PTR
;	       19.  C8101XV51	CLOSES 8101XV51
;	       20.  CRF4	STOPS 8101RF4
;
;
;
;	REFERENCE DOCUMENTS:
;	-------------------
;
;
;		DOCUMENT		      ORIGIN
;		~~~~~~~~		      ~~~~~~
;					
;	1. 	Excelerator design 		MILLER
;		DTDD 
;
;	2	Functional Specification	MILLER
;
;	3	I/O list 			MILLER
;		
;
;
;*******************************************************************************
;
;
;	DEFINE UNITS
;	------------
;
	UNIT GRUNLD
;ldk000	COMMON ELVCOM
	COMMON ALLOF0	;ldk000
	RUNIT GRUNLD						;gmp001
;KER000	COMMON ELVCOM,ALLOF0

;
;*******************************************************************************
;
; adm000 begin
#include <constants.h>
; adm000 end
; adm001 begin
#include <grunld_epn.h>
; adm001 end
#include <allof0_epn.h>		/* ldk000 */
; adm002 begin
#include <grunld_upf.h>
; adm002 end
#include <skel_upf.h>
;VCM013
#include <allof0_upf.h>

;
;	VARIABLE DEFINITION
;	-------------------
	UNIT_SG == GRUNLD

; adm001 begin the following are in grunld_epn.h
;KER000 replaced with device	GU_DUST_BLOWER_PRESS_HI		== '8101PS2'	;MRP001
;KER000 replaced with device	GU_DUST_BLOWER_PRESS_NORMAL 	== '8101PS1'	;MRP001
;	GU_DUST_BLOWER			== '8101C33'							;MRP001
; adm001 end

;KER000 part of skel.h	DEV_PTR			== VPT001
;KER000 part of skel.h/sc_error_lin	ERROR_LIN 	== VIN001
;KER000 part of skel.h/sc_error_num	ERROR_NUM 	== VIN002
;KER000 part of skel.h	FAIL_MSG			== VSG000
;KER000 part of skel.h/sa_tmp_sg	SA_TEMP_SG	== VSG009	;KER000 messaging
;ldk001	PRGE_BLOWR_PTR        	== VPT005  ;VCMO11 C22 STIL IN USE
;KER000 part of skel.h/sa_message	SA_MSG	 	== VSG001
;KER000 part of skel.h/sa_2_message	SA_MSG2		== VSG005	;KER000
;KER000 part of skel.h/sa_3_message	SA_MSG3		== VSG006	;KER000
;KER000 part of skel.h/sa_4_message	SA_MSG4		== VSG007	;KER000
;KER000 part of skel.h/sa_5_message	SA_MSG5		== VSG008	;KER000
;KER000 part of skel.h/sa_ex1_fg	EXPR1		== VFG022
;KER000 part of skel.h/sa_ex2_fg	EXPR2		== VFG028   	;KER000
;KER000 part of skel.h/sa_ex3_fg	EXPR3		== VFG029   	;KER000
;KER000 part of skel.h/sa_ex4_fg	EXPR4		== VFG030   	;KER000
;KER000 part of skel.h/sa_ex5_fg	EXPR5		== VFG031   	;KER000

; adm001 begin the following are in grunld_upf.h
;	AUTO_SHUTDN             	== VFG011	;VCM003
;	BLOWER_PRESSURE_TMR    	== VST000
;	BLOWR_PRESSURE_FLAG   	== VFG000
;	BLOWER_ZERO_PRESSURE_TMR 	== VST004
;	BLOWR_ZERO_PRESSURE_FLAG 	== VFG007
;	BMLT_WEIGHT     	== VFL000
;	CARA_WEIGHT    	 	== VFL001
;	CLNR_DRV_PTR          	== VPT000
;	DIVERTER_POSITION_FLAG 	== VFG001
;	DIS_SPEC_MALT_DEV_FG 	== VFG013	;VCM004 disable daily run
;	DUST_AIRLOCK_PTR      	== VPT002
;	DUSTCOLL_FAN_PTR      	== VPT003
;	DUSTCOLL_HI_LVL_PTR   	== VPT004
;	ESTOP_TYPE	      	== VIN000
;	FAIL_FLAG		== VFG009
;	GRTS_WEIGHT  		== VFL002
;	GRAIN_WEIGHT           	== VIN003
;	GRAINS_CHECK_OK_FLAG   	== VFG002
;	GU_STATE	      	== VIN004
;	LAST_GU_SILO		== VIN014	;KER000 keep up with last silo
;	SA_TEMP_INT		== VIN015	;KER000 messaging
;	SA_TEMP_INT2		== VIN016	;KER000 messaging
;	HI_HOP_LVL           	== VFG023
;	HOPPER_FLAG	      	== VFG003
;	HOPPER_TMR           	== VST001
;	K4_RUNNING		== VFG008
;	MALT_WEIGHT     	== VFL003      
;	RF41_INT_FLAG		== VFG004
;	RUN_SPEC_MALT_DEV_FG 	== VFG012	;VCM004 run spec. malt devs
;	SA_STATUS	      	== VSG002
;	SEQ_STATUS	     	== VSG003
;	SILO_DUST_VLV_PTR     	== VPT006
;	SILO_INDICATOR		== VIN005
;	SILO_INVENTORY_PTR    	== VPT007
;	SILO_LVL_PTR          	== VPT008
;	SEARCH_DIV_POSITION_TMR	== VST002
;	SPEC_MALT_TIME		== VIN012	;VCM004
;	SPEC_MALT_TMR		== VST006	;VCM004
;	UNLOAD_TMR             	== VMT000
;	HOP_HI_LVL_SD_TMR	== VST007
;	M8      		== VFG014
;       M7      		== VFG015
;	M6      		== VFG016
;	M5      		== VFG017
;	M4      		== VFG018
;	M3      		== VFG019
;	M2      		== VFG020
;	M1      		== VFG021
;	LEVEL_BAD_FG		== VFG022
;	G1			== VFG024	;KER000
;	G2 			== VFG025   	;KER000
;	G3			== VFG026   	;KER000
;	G4			== VFG027   	;KER000
;	GRAIN_SILO_LOCK_FG   	== VFG028	;KER000	;grain/silo selector lockout
;	SILO_SELECT_SG		== VSG000	;KER000
;	GRAIN_SEL_INT		== VIN001
;	SILO_SEL_INT		== VIN002
;	ROTARY_DIVERT_TRAV	== VFG032 	;KER000
;	READY_SEAL		== VFG033     	;KER000
;	READY_UNLOAD		== VFG034     	;KER000
;	SILO_PROX_SWITCH	== VPT009	;KER000
; adm002 end
;KER000 added for forward on diverter if able and moved to the epn.h file
;	GU_SILO_PROX_M8		== '8101ILS2'	
;	GU_SILO_PROX_M7		== '8101ILS1'
;	GU_SILO_PROX_M6		== '8101ILS12'
;	GU_SILO_PROX_M5		== '8101ILS11'
;	GU_SILO_PROX_M4		== '8101ILS10'
;	GU_SILO_PROX_M3		== '8101ILS9'
;	GU_SILO_PROX_M2		== '8101ILS8'
;	GU_SILO_PROX_M1		== '8101ILS7'
;	GU_SILO_PROX_G1		== '8101ILS3'
;	GU_SILO_PROX_G2		== '8101ILS4'
;	GU_SILO_PROX_G3		== '8101ILS5'
;	GU_SILO_PROX_G4		== '8101ILS6'
;*******************************************************************************
;
;
;	EQUATES
;	------- 
;KER000					      ;KER TEMP TIMES INSERTED HERE TO SPEED SIMULATION
	ONE_MINUTE			== 60
	ONE_AND_HALF_MINUTE		== 90 
	TWO_MINUTE			== 120
	HALF_MINUTE			== 30 
	MAX_BLOWER_PRESSURE_TIME	== 30
	MAX_BLOWER_ZERO_PRESSURE_TIME	== 60
	MAX_HOPPER_TIME			== 300
	MAX_SRCH_TIME			== 60	
	HOP_HI_LVL_DELAY		== 5
	HOP_HI_LVL_SD_DELAY		== 300
	; alarm destination indices (ADIs) and alarm lamp numbers
	PRI_ADI		== 3
	LOG_ADI		== 3
	CON_ADI		== 0
	GUSA_ADI	== 0
	GUSA_ALARM	== 2
	SABL_ALARM 	== 2
	; lamp modes for skid panel

; adm000 begin the following are in constants.h
;	BLACK		== 0
;	GREEN		== 1
;	FLASH_RED	== 2
;	FLASH_YEL	== 3
;
;	T_0 == 1	;TEMP BIT $T0
;	T_1 == 2	;TEMP BIT $T1
;	T_2 == 4	;TEMP BIT $T2
;	T_3 == 8	;TEMP BIT $T3
;	T_4 == 16	;TEMP BIT $T4
;	T_5 == 32	;TEMP BIT $T5
;	T_6 == 64	;TEMP BIT $T6
;	T_7 == 128	;TEMP BIT $T7
;	T_8 == 256	;TEMP BIT $T8
;	T_9 == 512	;TEMP BIT $T9
;	T_10 == 1024	;TEMP BIT $T10
;	T_11 == 2048	;TEMP BIT $T11
;	T_12 == 4096	;TEMP BIT $T12
;	T_13 == 8192	;TEMP BIT $T13
;	T_14 == 16384	;TEMP BIT $T14
;	T_15 == 32768	;TEMP BIT $T15
;	T_16 == 1	;TEMP BIT $T16
;	T_17 == 2	;TEMP BIT $T17
;	T_18 == 4	;TEMP BIT $T18
;	T_19 == 8	;TEMP BIT $T19
;	T_20 == 16	;TEMP BIT $T20
;	T_21 == 32	;TEMP BIT $T21
;	T_22 == 64	;TEMP BIT $T22
;	T_23 == 128	;TEMP BIT $T23
;	T_24 == 256	;TEMP BIT $T24
;	T_25 == 512	;TEMP BIT $T25
;	T_26 == 1024	;TEMP BIT $T26
;	T_27 == 2048	;TEMP BIT $T27
;	T_28 == 4096	;TEMP BIT $T28
;	T_29 == 8192	;TEMP BIT $T29
;	T_30 == 16384	;TEMP BIT $T30
;	T_31 == 32768	;TEMP BIT $T31
;
;
;	C_0 == 1	;COMMAND BIT $C0
;	C_1 == 2	;COMMAND BIT $C1
;	C_2 == 4	;COMMAND BIT $C2
;	C_3 == 8	;COMMAND BIT $C3
;	C_4 == 16	;COMMAND BIT $C4
;	C_5 == 32	;COMMAND BIT $C5
;	C_6 == 64	;COMMAND BIT $C6
;	C_7 == 128	;COMMAND BIT $C7
;
;
;	B_0 == 1	;BIT 0 MASK
;	B_1 == 2	;BIT 1 MASK
;	B_2 == 4	;BIT 2 MASK
;	B_3 == 8	;BIT 3 MASK
;	B_4 == 16	;BIT 4 MASK
;	B_5 == 32	;BIT 5 MASK
;	B_6 == 64	;BIT 6 MASK
;	B_7 == 128	;BIT 7 MASK
;
;	S_0 == 1	;STATUS BIT $S0
;	S_1 == 2	;STATUS BIT $S1
;	S_2 == 4	;STATUS BIT $S2
;	S_3 == 8	;STATUS BIT $S3
;	S_4 == 16	;STATUS BIT $S4
;	S_5 == 32	;STATUS BIT $S5
;	S_6 == 64	;STATUS BIT $S6
;	S_7 == 128	;STATUS BIT $S7
;
;
;	F_0 == 1	;FAULT BIT $F0
;	F_1 == 2	;FAULT BIT $F1
;
;
;	M_0 == 1	;MODE BIT $M0
;	M_1 == 2	;MODE BIT $M1
;	M_2 == 4	;MODE BIT $M2
; adm000 end            
;KER000 START	
	MALT		== 1
	MILLERMALT		== 1
	G1_G4		== 2
	COORSMALT		== 2
	BLKMALT		== 3
	CARAMALT 	== 4
	MUNICHMALT 	== 5
	CHOCMALT == 6 ;pbh002
	CARA1030MALT == 7 ;pbh002
	SILO1		== 1
	SILO2		== 2
	SILO3		== 3
	SILO4		== 4
	SILO5		== 5
	SILO6		== 6
	SILOG1		== 7
	SILOG2		== 8
	SILOG3		== 9
	SILOG4		== 10
	SILO7		== 11
	SILO8		== 12
	LAST_GU_SILO 	= SILO_INDICATOR	;keep last selected silo
;KER000 END



;*******************************************************************************
;
;		SET ERROR SUBROUTINES
;
;*******************************************************************************


	ON ERROR GOSUB ERRSUB		;define error handling routine
	ON HOLD GOSUB HOLDSUB		;define hold interrupt handling routine


;*******************************************************************************
;*******************************************************************************
;
MAIN:
;
	;Initialize pointers and flag (needed in interlock program) and bits.

	ASSIGN SILO_PROX_SWITCH		= '8101ILS3'	;KER000
;KER000	ASSIGN SILO_LVL_PTR		= '8102LH11'
	ASSIGN SILO_LVL_PTR		= '8102LSH11'
	ASSIGN SILO_DUST_VLV_PTR	= '8101XV101'
;KER000	ASSIGN DUSTCOLL_HI_LVL_PTR	= '8101LH41'
	ASSIGN DUSTCOLL_HI_LVL_PTR	= '8101LSH41'	;KER000 changed from din to dev
;;ajw000	ASSIGN DUSTCOLL_FAN_PTR		= '8101C71'   
	ASSIGN DUSTCOLL_FAN_PTR		= '8101C41'	;;ajw000
;;ajw000	ASSIGN CLNR_DRV_PTR		= '8101SR71'
;ldk000	ASSIGN CLNR_DRV_PTR		= '8101SR41'	;ajw000
;ajw000	ASSIGN DEV_PTR			= '8101SR71'
;ldk000	ASSIGN DEV_PTR			= '8101SR41'	;ajw000
	ASSIGN DUST_AIRLOCK_PTR		= '8101RF1'						
 
;KER000 equipment removed 
;ldk001	ASSIGN PRGE_BLOWR_PTR		= '8101C22'  ;VCMO11
;	GU_DUST_BLOWER_PRESS_HI		== '8101PS2'	;MRP001
;   	GU_DUST_BLOWER_PRESS_NORMAL	== '8101PS1'	;MRP001
;	GU_DUST_BLOWER			== '8101C33'							;MRP001
	RF41_INT_FLAG = 1
	FAIL_MSG = ""
	SA_MESSAGE = ""
	SA_2_MESSAGE = ""
	SA_3_MESSAGE = ""
	SA_4_MESSAGE = ""
	SA_5_MESSAGE = ""
	ESTOP_TYPE = 2
;KER000 removed from service per ICC 	
;	TURNOFF '8101PL80' 
;	TURNOFF '8101PL81'   
;KER000	'8101GU':DEV_TMP1 = AND('8101GU':DEV_TMP1,NOT(T_25))     
;KER000	'8101GU':DEV_TMP1 = AND('8101GU':DEV_TMP1,NOT(T_26))     
;KER000	'8101GU':DEV_TMP1 = AND('8101GU':DEV_TMP1,NOT(T_27))
	BMLT_WEIGHT	= 0
	CARA_WEIGHT	= 0
	GRTS_WEIGHT	= 0 
	MALT_WEIGHT	= 0                  
	K4_RUNNING	= 0
	ROTARY_DIVERT_TRAV = 0

	GOTO	GU1
	
;===============================================================================
;                       MAINTENANCE WAIT
;===============================================================================
ST0:
	IF SC_SA_MAINT_START_CMD = 1	THEN
		BEGIN
                SC_SA_MAINT_START_CMD = 0			; gmp001
		SC_SA_MAINT_STOP_CMD = 0
		SA_STATUS = "MAINTENANCE WAIT"
		GU_STATE = 0
		DIVRT_MAINT_MODE = 1
		SEQ_STATUS = ""
		SA_MESSAGE = ""									
		SA_2_MESSAGE = ""									
		SA_3_MESSAGE = ""
		SC_SA_OFF_CMD = 0	   	;KER000
		SC_SA_START_CMD = 0	   	;KER000
		SC_SA_CONT_CMD = 0		;KER000
;		SC_SA_MAINT_CMD = 0		;KER000
;KER000		GOSUB STATEINIT                     ;init state 
;KER000		GOSUB ADST0	                    ;align devices for MAINTENANCE WAIT
;KER000		GOSUB CLRTMRS
;KER000		GOSUB RESETVARS
		SC_SA_OFF_CMD = 0	   	;KER000
		SC_SA_START_CMD = 0	   	;KER000
;		SC_SA_CONT_CMD = 0		;KER000
		SC_SA_MAINT_STOP_CMD = 0
		ROTARY_DIVERT_TRAV = 0
		GRAIN_SILO_LOCK_FG = 0
			READY_SEAL = 0
; adm000		SA_2_MESSAGE = "WAITING FOR CONTINUE CMD"
		IF AND('8101K4':DEV_STAT,S_1) THEN
			GOSUB C8101K4		;grain unloading drag conveyor
		IF AND('8101RF41':DEV_STAT,S_1) THEN
			GOSUB C8101RF41	;grain unloading receiver airlock
		IF AND('8101C12':DEV_STAT,S_1) THEN
			GOSUB C8101C12	;grain unloading pressure blower
		IF AND('8101Z1M':DEV_STAT,S_1) THEN
			GOSUB C8101Z1M	;rotary diverter motor

		END
	WAIT 1								; gmp001
	GOTO ST0SS
	;----------------------------------
	;       steady state conditions
	;----------------------------------
ST0SS:

;KER000	GOSUB UPDATESKID                ;update skid lamp
;KER000	GOSUB CHKANYSTATEHELD			;check if any step is HELD

	
	
	;----------------------------------
	;       transition conditions
	;----------------------------------

;KER000	TR2_FG = SEQ_ENABLE_FG
;KER000	TR3_FG = SC_SA_PROC_WAIT_CMD

;KER000	GOSUB CHKFORCESTATE					;check to see if we need to transistion to another state
;KER000	IF (SA_STATE1_HELD_FG) THEN			;hold in step
;KER000		BEGIN
;KER000		WAIT 1
;KER000		GOTO ST1SS                      ;go back to top of steady state loop
;KER000		END
        WAIT 2
	GOSUB CKGRAINSEL     			;check for grain mismatch
	
	IF (GRAINS_CHECK_OK_FLAG = 0) THEN 	;grains/silo ok 
		BEGIN
		GOTO ST0SS
		END
		

	GOSUB CHECKGUSILOSEL	  		;assign pointers per grain and silo selections and check dust coll levels
		
	WAIT 1								;gmp001

	GOSUB MAINTDIVERTALIGN

					
; adm000	IF (SC_SA_CONT_CMD) THEN
; adm000	    GOTO GU1                                

	IF SC_SA_MAINT_STOP_CMD = 1	THEN				; If SC SA MAIN STOP CMD
		BEGIN;1
		SC_SA_MAINT_STOP_CMD = 0				; gmp001
		GOTO GU1
		END;1

	WAIT 1

	GOTO ST0SS                      ;go back to top of steady state loop	

;===============================================================================
;		I D L E    A N D    W A I T I N G 
;===============================================================================
;
;The idle and waiting state is the first state of the grains unloading process.
;This state is transitioned into from the estop and shutdown unloading states.
;
;The idle and waiting state checks the following:
;  * that the diverter is in position
;  * that the selector switches and limit switches identify a proper grain type
;  * that all devices are in auto
;  * that the grains unloading start pushbutton has been depressed.
;
;The process will remain in the idle and waiting state until all of the above
;conditions are met.  Then the process will transition to the starting unloading
;state.  
;
;The idle and waiting state does the following:
;  * assigns grains unloading pointers 
;  * seals and opens diverter as required
;  * opens appropriate silo dust collector valve
;  * closes appropriate silo dust collector valves
;  * sets grains unloading status to ready. 
;
;If any device fails to open during this state, the process will transition to
;the estop unloading state.  If any device fails to close during this state,
;the process will transition to the failure state.  If the diverter fails to
;open or seal, or if valve 8101xv71 fails to open to the proper silo, the
;process will transition to the failure state.
;
GU1:	
	SA_STATUS = "IDLE AND WAITING"
	GU_STATE = 1

	DIVRT_MAINT_MODE = 0
	SEQ_STATUS = ""
	SA_MESSAGE = ""									
	SA_2_MESSAGE = ""									
	SA_3_MESSAGE = ""									
 	LAMP GUSA_ADI,GUSA_ALARM,GREEN           
;	PRINT LOG_ADI,"%p",SA_STATUS		;DWM001
	AUTO_SHUTDN = 1            	;VCM004
	TIMEROFF SPEC_MALT_TMR     	;VCM004
	TIMERCLR SPEC_MALT_TMR     	;VCM004
	BMLT_WEIGHT = 0            	;VCM006
	CARA_WEIGHT = 0            	;VCM006
	GRTS_WEIGHT = 0            	;VCM006
	MALT_WEIGHT = 0            	;VCM006
	GRAIN_WEIGHT = 0           	;VCM006
	GRAIN_SILO_LOCK_FG = 0
	SC_SA_OFF_CMD = 0	   		;adm000
	SC_SA_START_CMD = 0	   		;adm000
	SC_SA_CONT_CMD = 0			;adm000
	SC_SA_MAINT_START_CMD = 0		;adm000
	SC_SA_MAINT_STOP_CMD = 0		;adm000
;KER000 START
	READY_SEAL = 0				;diverter in postion, ready for seal
	READY_UNLOAD = 0			;ready to advance to starting unloading state
	ROTARY_DIVERT_TRAV = 0			;rotary diverter beginning alignment
	LEVEL_BAD_FG = 0			;selected silo or unload dust collector high level flag
	NOP
	DIVERTER_POSITION_FLAG = 0               
	GRAINS_CHECK_OK_FLAG = 0
	GRAIN_SEL_INT = 0  ;VCM013	

	SILO_DUST_COLL_HI_DP_POST_FG = 0		;ajw001
	SILO_DUST_COLL_HI_DP_ACK_FG = 0			;ajw001
	SILO_DUST_COLL_LO_DP_POST_FG = 0		;ajw001
	SILO_DUST_COLL_LO_DP_ACK_FG = 0			;ajw001
	PT41_PRINT_FG = 0  ;VCM014
        WAIT 1

	GOSUB CHECKAUTO      			;check devices are in auto

;KER000 added these stop subroutines
	IF AND('8101K4':DEV_STAT,S_1) THEN
		GOSUB C8101K4		;grain unloading drag conveyor
	IF AND('8101RF41':DEV_STAT,S_1) THEN
		GOSUB C8101RF41	;grain unloading receiver airlock
	IF AND('8101C12':DEV_STAT,S_1) THEN
		GOSUB C8101C12	;grain unloading pressure blower
	IF AND('8101Z1M':DEV_STAT,S_1) THEN
		GOSUB C8101Z1M	;rotary diverter motor

GU1FT:
	WAIT 1						; gmp001
	; Initialize flags and timers
	TIMEROFF SEARCH_DIV_POSITION_TMR
	TIMERCLR SEARCH_DIV_POSITION_TMR
	GRAIN_SILO_LOCK_FG = 0	;grain/silo selector lockout
	TIMEROFF UNLOAD_TMR
	TIMERCLR UNLOAD_TMR

GU1WT:
	WAIT 1
	IF (GRAIN_SEL_INT = 0) THEN		;grain selector
		BEGIN
		SA_MESSAGE = "WAITING FOR GRAIN SELECT"
		GRAINS_CHECK_OK_FLAG = 0		;reset confirmed silo on popups
	        GOTO GU1FT
		END
GU1CD:
	WAIT 1						; gmp001
	IF (SC_SA_MAINT_START_CMD) THEN
		GOTO ST0				;goto maintenance wait state for diverter maintenance

	GOSUB CKGRAINSEL     				;check for grain mismatch
	WAIT 1
	IF (GRAINS_CHECK_OK_FLAG = 0) THEN
		BEGIN
		GOTO GU1WT
		END
	GOSUB CHECKGUSILOSEL	  			;assign pointers per grain and silo selections and check dust coll levels
	WAIT 1
	IF (LEVEL_BAD_FG = 1) THEN
		BEGIN
		GOTO GU1FT
		END

;mrp005 start
;	IF (RUN_SPEC_MALT_DEV_FG = 1) & (DIS_SPEC_MALT_DEV_FG = 0) THEN 	;run special malt if time and enabled automatic
;		BEGIN
;		SA_3_MESSAGE = "RUN SPEC MALT DEV ENABLED"
;		GOTO GU6
;		END
;mrp005 end
	;-------------------------------------
	;	transition conditions
	;-------------------------------------
	IF AND(GU_DIV_SEAL:DEV_MODE,M_2) THEN	;KER000 seal in override
		BEGIN
		SA_2_MESSAGE = "REMOVE SEAL FROM OVERRIDE"
		SC_SA_START_CMD = 0
		SA_MESSAGE = ""
		GOTO GU1WT
		END
	ELSE
		IF COMPAR(SA_2_MESSAGE,"REMOVE SEAL FROM OVERRIDE",25,EQ) THEN
			BEGIN
			SA_2_MESSAGE = ""
			END


	IF (SC_SA_START_CMD = 0) THEN      ;READY_UNLOAD
		BEGIN	
		SA_MESSAGE = "WAITING START COMMAND"
		SA_2_MESSAGE = "ALIGN ROTARY DIVERTER NEXT"
;VCM012
		IF !AND(GU_RAIL_PIT_LO_LVL:DEV_STAT,S_1) THEN
			BEGIN
			SA_4_MESSAGE = "RAIL PIT NOT EMPTY"
			SA_5_MESSAGE = "CHECK FOR GRAIN MISMATCH"
			END			
		GOTO GU1WT 
		END
	SA_2_MESSAGE = ""
	SA_3_MESSAGE = ""
	;-------------------------------------
	;	final condition checks and Alignments
	;-------------------------------------
	GRAIN_SILO_LOCK_FG = 1
	GOSUB ALIGNDIVERTER 					;set diverter to proper silo, check position timer and seal 
	WAIT 2
 	IF (READY_UNLOAD = 0) THEN
		GOTO GU1WT
	GOSUB CHECKSWITCHES 	       			;check if more than one switch is made 
	GOSUB CHECKAUTO      				;check devices are in auto
	GOSUB ADST1						;align devices
;KER000 END
	;Set grains unloading status to ready
;KER000	'8101GU':DEV_TMP1 = OR('8101GU':DEV_TMP1,T_25) 
;KER000	'8101GU':DEV_TMP1 = AND('8101GU':DEV_TMP1,NOT(T_28))
;KER000	OPEN '8101GU'	  
;KER000 removed from service per ICC	TURNON '8101PL81'
GU1TC:
	IF (SC_SA_OFF_CMD) THEN	;if stop cmd should happen before transition to start unloading
		GOTO GU1
;KER000 RUN AUTO	IF (RUN_SPEC_MALT_DEV_FG = 1) & (DIS_SPEC_MALT_DEV_FG = 0) THEN   ;VCM004
;		BEGIN
;		GOTO GU6
;		END
;	ELSE
		GOTO GU2
					 ;seal not in override VCMXXX
;KER000 relocated above	IF AND('8101GU':DEV_TMP0,T_7)&('8101Z1DS':DEV_MODE != M_2)THEN
;			GOTO GU2

;KER000
;relocated to checkauto subroutine
;NOTAUTO:
; adm000 begin                                               
;	LAMP GUSA_ADI,GUSA_ALARM,FLASH_YEL
;	LAMP GUSA_ADI,GUSA_ALARM,YELLOW
; adm000 end
;	WAIT 3
;KER000	WAIT 1
;KER000	GOTO GU1FT

;===============================================================================
;		S T A R T I N G    U N L O A D I N G
;===============================================================================
;
;The starting unloading state is the second state of the grains unloading
;process.  This state is transitioned into from the idle and waiting state.
;
;The starting unloading state checks the following:
;  * that the appropriate silo level is not high
;  * that the appropriate dust collector levels are not high
;  * that the grains unloading blower pressure is not high.
;
;If any of the above conditions are not met, the process will transition to
;the estop unloading state.  
;
;The starting unloading state does the following:
;  * starts appropriate dust collector fans, blowers, drives and airlocks
;KER000 relocated to adst1  * opens valve 8101xv71 to black malt and caramel malt silos as required
;  * starts grains unloading blower 8101c12
;	* starts dust blower 8101c33						;mrp001
;  * starts drag conveyor 8101k4 as required.
;
;If any device fails to open during this state, the process will transition to
;the estop unloading state.
GU2:	
	SA_MESSAGE = ""
	SA_2_MESSAGE = ""
	SA_3_MESSAGE = ""									
	SA_STATUS = "STARTING UNLOADING"
	GU_STATE = 2
	SEQ_STATUS = ""
	SC_SA_START_CMD = 0
	SC_SA_CONT_CMD = 0
; adm000	SC_SA_MAINT_CMD = 0
	LAMP GUSA_ADI,GUSA_ALARM,GREEN                               
	PRINT LOG_ADI,"%p",SA_STATUS		;DWM001
	READY_SEAL = 0		;diverter in postion, ready for seal
	READY_UNLOAD = 0		;ready to advance to starting unloading state
	ROTARY_DIVERT_TRAV = 0	;rotary diverter beginning alignment
	LEVEL_BAD_FG = 0		;selected silo or unload dust collector high level flag
   LAST_GU_SILO = SILO_INDICATOR	;keep last selected silo
   K4_RUNNING = 0

;JMS001 START
		IF (SILO_SEL_INT = SILO7) | (SILO_SEL_INT = SILO8) THEN			
			BEGIN
			'8101FC41A':CB_OTHI:1 = 80
			'8101FC41A':CB_OTLO:1 = 60
			'8101FC41A':PID_SPVL:1 = 7.5
         PUTAUTO '8101FC41A'
         END
			ELSE
         BEGIN
			'8101FC41A':CB_OTHI:1 = 80
			'8101FC41A':CB_OTLO:1 = 60
			'8101FC41A':PID_SPVL:1 = 8
         PUTAUTO '8101FC41A'
         END
;JMS001 END
;gmp002 start
	GOSUB O8101C33					; Start Malt SiloDust Collector Pressure Blower - 8101C33
	SA_2_MESSAGE = "60 SEC WAIT FOR 8101C33 START"
;			123456789012345678901234567890	; Ruler for 30 characters
	WAIT 60						; Wait for start
	SA_2_MESSAGE = ""				; Clear Message
;gmp002 end	
	
		;Check levels and pressure 
;KER000	IF AND('8101PSH121':DEV_STAT,S_1) THEN
;	IF AND(GU_PRESSURE_BLOWER_HI:DEV_STAT,S_1) THEN
	IF ('8101PT711':AI_MEAS > 9.0) THEN
		BEGIN
;KER000		SA_MESSAGE = "8101PSH121 PRESSURE HIGH"
		SA_2_MESSAGE = "8101PT711 PRESSURE HIGH"
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
      K4_RUNNING = 0
		GOTO ESTOP2
		END
;KER000	IF AND('8101PS1':DIN_VAL,0) THEN			;mrp001
	IF AND(GU_SPENT_BLOWER_PRESS_LO:DEV_STAT,S_1) THEN
		BEGIN
;KER000		SA_MESSAGE = "8101PS1 PRESSURE NOT NORMAL"
;gmpz1		SA_2_MESSAGE = "SPENT GRAIN BLOWER LO PSI"
		SA_2_MESSAGE = "SILO MALT DUST BLOWER LO PSI"
;				123456789012345678901234567890
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		GOTO ESTOP2
		END

;KER000	IF AND('8101PS2':DIN_VAL,0) THEN			;mrp001
	IF AND(GU_SPENT_BLOWER_PRESS_HI:DEV_STAT,S_1) THEN
		BEGIN
;KER000		SA_MESSAGE = "8101PS2 PRESSURE HIGH"
		SA_2_MESSAGE = "SPENT GRAIN BLOWER HIGH PSI"
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		GOTO ESTOP2
		END
;KER000	IF (SILO_LVL_PTR:DIN_VAL = 0) THEN
	IF AND(SILO_LVL_PTR:DEV_STAT,S_1) THEN	;KER000 changed from din to dev
		BEGIN
;KER000		SA_MESSAGE = "SILO LEVEL HIGH"
		SA_2_MESSAGE = "SILO LEVEL HIGH"
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		GOTO ESTOP1
		END
;KER000 IF (DUSTCOLL_HI_LVL_PTR:DIN_VAL = 0) THEN
	IF AND(DUSTCOLL_HI_LVL_PTR:DEV_STAT,S_1) THEN	;KER000 changed from din to dev
		BEGIN
;KER000		SA_MESSAGE = "8101F4/F7 DUST COLL. LVL HI"             ;KAN004
		SA_2_MESSAGE = "8101F4/F7 DUST COLL. LVL HI"             ;KAN004
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		GOTO ESTOP1
		END
		
;KER000	IF AND('8101LH11':DEV_STAT,S_1) THEN
	IF AND(GU_TRKHOP_DUST_HI_LVL:DEV_STAT,S_1) THEN
		BEGIN
;KER000		SA_MESSAGE = "8101LSH11 LEVEL HIGH"
		SA_2_MESSAGE = "8101LSH11 LEVEL HIGH"
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		GOTO ESTOP1                           
		END
;---------------------------------------------
;	command devices
;---------------------------------------------
;
 	;Check grains unloading type                       
	;pbh002IF (GRAIN_SEL_INT = MILLERMALT | GRAIN_SEL_INT = COORSMALT | GRAIN_SEL_INT = MUNICHMALT) THEN
	IF (GRAIN_SEL_INT = MILLERMALT | GRAIN_SEL_INT = COORSMALT | GRAIN_SEL_INT = MUNICHMALT | GRAIN_SEL_INT = CHOCMALT | GRAIN_SEL_INT = CARA1030MALT ) THEN  ;pbh002 ADDED CHOCMALT AND CARA1030MALT
		BEGIN
;VCM009	        ASSIGN DEV_PTR = '8101XV51'
;VCM009	        FAIL_MSG = "VALVE 8101XV51 FAILED TO OPEN"
;VCM009	        GOSUB OPENDEV3
;KER000 replaced by OAIRLOCK below		GOSUB O8101RF4
		GOSUB O8101C33	;KER001
	       END

	
                                     
;KER000 relocated to adst1
;	IF (GRAIN_SEL_INT = BLKMALT) | (GRAIN_SEL_INT = CARAMALT) THEN
;		BEGIN
;;KER000 removed, duplicated		GOSUB OFAN		
;;KER000 removed, duplicated      	GOSUB ODRIVE         
;
;		IF (SILO_SEL_INT = SILO8) THEN
;			BEGIN
;			IF (AND( '8101XV71':DEV_DFLG,F_0) | AND( '8101XV71':DEV_STAT,S_4)) THEN
;				GOTO XV71FLT
;			IF AND( '8101XV71':DEV_STAT,S_1) THEN
;				GOTO XV71OK
;			IF !AND( '8101XV71':DEV_MODE,M_0) THEN
;				BEGIN
;;KER000				SA_MESSAGE = "DEVICE NOT IN AUTO"
;				SA_2_MESSAGE = "DEVICE NOT IN AUTO"
;				PRINT PRI_ADI, "%P",SA_2_MESSAGE
;				GOTO FAIL
;				END                                       
;;KER000		'8101XV71':DEV_TMP1 = OR( '8101XV71':DEV_TMP1,T_26)   
;			GOSUB O8101XV71	;KER000 added for new mdv
;			WAITUNTIL (AND( '8101XV71':DEV_STAT,S_1) | AND('8101XV71':DEV_DFLG,F_0)) COUNT 60,XV71FLT
;			IF AND( '8101XV71':DEV_DFLG,F_0)  THEN
;				BEGIN
;XV71FLT:         		;KER000 SA_MESSAGE = "8101XV71 TO BLACK MALT FAILED"
;				SA_2_MESSAGE = "8101XV71 TO BLACK MALT FAILED"
;				PRINT PRI_ADI, "%P",SA_2_MESSAGE	
;				GOTO FAIL
;				END
;			END                                                               
;		ELSE
;			BEGIN
;			ASSIGN DEV_PTR = '8101XV71'
;			FAIL_MSG = "8101XV71 TO CARAMEL MLT FAILED"
;;KER000		GOSUB CLOSDEV
;			GOSUB CLOSDEV2
;			WAIT 2 ;KER000 	;timer for inlk to clear on airlock
;			END 
;		END  
;XV71OK: 
;
	GOSUB OFAN		;KER000
	GOSUB ODRIVE         	;KER000
	GOSUB OAIRLOCK 		;KER000 

;KER000 replaced with OAIRLOCK above		ASSIGN DEV_PTR = DUST_AIRLOCK_PTR
;KER000		FAIL_MSG = "8101RF7 AIRLCK FAILED TO START"
;KER000	GOSUB OPENDEV
;KER000		GOSUB OPENDEV2					      
;KER000		END
 					  
    ;SPECIALTY MALT USING PLANT AIR
;	   BEGIN
;ldk001	IF (DUST_COLLECTOR_USE_PLANT_AIR = 0)THEN  ;VCMO11	  ;mrp002
;ldk001		BEGIN
;ldk001		ASSIGN DEV_PTR = PRGE_BLOWR_PTR               ;VCMO11
;ldk001		FAIL_MSG = "8101C22 BLOWR FAILED TO START"   ;VCMO11
;ldk001		GOSUB OPENDEV2                                 ;VCMO11
;ldk001		END
;      	END

	WAIT 10
	GOSUB O8101C12
;ker000	GOSUB O8101C33
	WAIT 10
	GOSUB O8101RF1
	WAIT 10
	GOSUB O8101C102
	WAIT 10	
	GOSUB O8101RF41
	WAIT 10

;KER000	IF ('8101LH441':DIN_VAL = 1) THEN
	IF AND('8101LSH441':DEV_STAT,S_0) & (K4_RUNNING = 0) THEN	;din replaced with dev
		BEGIN
		WAIT 2           ;VCM001 time for intlk to clear
		GOSUB O8101K4
		END
;	ELSE                                                                 ;JMS001 start
;		BEGIN                                                            
;;KER000		SA_MESSAGE = "8101LSH441 HI LEVEL PIT HOPPER"    ;MLB007   
;		SA_2_MESSAGE = "8101LSH441 HI LEVEL PIT HOPPER"    ;MLB007        
;		PRINT PRI_ADI, "%p",SA_2_MESSAGE                                  
;		GOTO ESTOP1						;KER000 for messaging and continue cmd 
;		END
	IF AND('8101LSH441':DEV_STAT,S_1) THEN	;din replaced with dev        
		BEGIN                                                             
		WAIT 30           ;Clean out time for hopper                 
	IF AND('8101LSH441':DEV_STAT,S_0) THEN	;din replaced with dev        
		BEGIN                                                            
		WAIT 2           ;VCM001 time for intlk to clear                  
		GOSUB O8101K4
		END
	ELSE
		BEGIN
;KER000		SA_MESSAGE = "8101LSH441 HI LEVEL PIT HOPPER"    ;MLB007
		SA_2_MESSAGE = "8101LSH441 HI LEVEL PIT HOPPER"    ;MLB007
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		GOTO ESTOP1						;KER000 for messaging and continue cmd
		END																				   
		END
                                                                       	;JMS001 end
;VCM010	ASSIGN DEV_PTR = '8101C101'
;VCM010	FAIL_MSG = "8101C101 BLOWR FAILED TO START"
;VCM010	GOSUB OPENDEV                           
;mrp003	ASSIGN DEV_PTR = '8101SR101'
;mrp003	FAIL_MSG = "8101SR101 DRIV FAILED TO START"
;mrp003	GOSUB OPENDEV
;KER000	                  
	;WAIT 15
	;---------------------------------------------
	;	transition conditions
	;---------------------------------------------
	IF (SC_SA_OFF_CMD) THEN		;KER000
		GOTO GU4                ;shutdown unloading
	GOTO GU3
                                                            

;===============================================================================
;		U N L O A D I N G
;===============================================================================
;
;The unloading state is the third state of the grains unloading process.
;This state is transitioned into from the starting unloading state.
;
;The unloading state checks the following:
;  * that no device has failed
;  * that the silo level is not high
;  * that the appropriate dust collector levels are not high 
;  * that the grains unloading blower does not have a high pressure.
;
;If any of the above conditions is not met, the process transitions to the
;estop unloading state.
;
;The unloading state also checks the following:
;  * that the hopper is not empty
;  * that the grains unloading stop button has not been depressed.
;
;If any of the above conditions is not met, the process transitions to the
;shutdown unloading state.
;
;The unloading state does the following:
;  * sets grains unloading status to running    
;  * starts and stops drag conveyor 8101k4 (depending upon hopper level)
;  * logs the unloading time when unloading has been completed.
;
;If any device fails to open during this state, the process will transition to
;the estop unloading state.  If any device fails to close during this state,
;the process will transition to the failure state.

GU3:	
	SA_STATUS = "UNLOADING"
	GU_STATE = 3
	SEQ_STATUS = "" 
	SA_MESSAGE = ""
	SA_2_MESSAGE = ""			     
	SA_3_MESSAGE = ""									
	LAMP GUSA_ADI,GUSA_ALARM,GREEN                               
	PRINT LOG_ADI,"%p",SA_STATUS		;DWM001

;KER000	'8101GU':DEV_TMP1 = OR('8101GU':DEV_TMP1,T_26)  
;KER000 removed from service per ICC	TURNON '8101PL80'  
	TIMERCLR UNLOAD_TMR
	TIMERON UNLOAD_TMR    
	TIMEROFF BLOWER_PRESSURE_TMR
	TIMERCLR BLOWER_PRESSURE_TMR
	TIMEROFF HOPPER_TMR
	TIMERCLR HOPPER_TMR
	TIMEROFF HOP_HI_LVL_SD_TMR
	TIMERCLR HOP_HI_LVL_SD_TMR
	HOPPER_FLAG = 0
	BLOWR_PRESSURE_FLAG = 0	
	HI_HOP_LVL = 0
   K4_RUNNING = 0
;
	;-------------------------------------
	;	steady state conditions
	;-------------------------------------
GU3SS:
	WAIT 1
;KER000	IF ('8101LH441':DIN_VAL = 0) THEN

	GOSUB DUSTALARMS          ;Check Silo dust collector pressures ajw001
	SA_EX1_FG = AND('8101LSH441':DEV_STAT,S_1)	;din replaced with dev
       SA_EX2_FG = HI_HOP_LVL = 0 

	IF (SA_EX1_FG & SA_EX2_FG) THEN	
		BEGIN					;MLB004
		SA_2_MESSAGE = "RAIL PIT HOPPER HI LEVEL"	;KER000
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
	  	TIMERCLR HOPPER_TMR          	;JFH000
		TIMERON HOPPER_TMR           	;JFH000
		WAIT 4					;KER000 drag conveyor is inlk with the hi level
		GOSUB C8101K4     			;getting failed to stop message
		HI_HOP_LVL = 1               	;JFH000
		TIMERCLR HOP_HI_LVL_SD_TMR		;KER000 added hi level shutdown delay
		TIMERON HOP_HI_LVL_SD_TMR
              END

	IF (HI_HOP_LVL = 1) THEN
		BEGIN
		SA_TEMP_INT = HOP_HI_LVL_SD_DELAY - HOP_HI_LVL_SD_TMR	;KER000 300 sec
		SA_TEMP_INT2 = FLTCNV(SA_TMP_SG,SA_TEMP_INT,4,0)
		SA_TEMP_INT = APPEND(SA_3_MESSAGE,"HI HOPPER SD IN ",SA_TMP_SG," MORE SEC")
		
		IF (HOP_HI_LVL_SD_TMR >= HOP_HI_LVL_SD_DELAY & HI_HOP_LVL = 1) THEN
			BEGIN
			TIMEROFF HOP_HI_LVL_SD_TMR	;KER000 added hi level shutdown delay
			TIMERCLR HOP_HI_LVL_SD_TMR
			SA_2_MESSAGE = "SD ON RAIL PIT HOPPER HI LVL"
			GOTO FAIL
			END
		END

       SA_EX1_FG = (HOPPER_TMR >= (HOP_HI_LVL_DELAY)) & (HI_HOP_LVL = 1) ;JFH000	;5 sec delay on restart?
;KER000	IF (EXPR1 & ('8101LH441':DIN_VAL = 1)) THEN                 ;JFH000
		IF (SA_EX1_FG & AND('8101LSH441':DEV_STAT,S_0)) THEN
		BEGIN                                            ;JFH000
		TIMEROFF HOPPER_TMR                              ;JFH000
		TIMERCLR HOPPER_TMR                              ;JFH000
		TIMEROFF HOP_HI_LVL_SD_TMR	;KER000 added hi level shutdown delay
		TIMERCLR HOP_HI_LVL_SD_TMR
              HI_HOP_LVL = 0                                   ;JFH000
              END
;KER000 	ELSE
;	   BEGIN						      
;DWM00X
	   IF (K4_RUNNING = 0) & (HI_HOP_LVL = 0) THEN              ;JFH000
		BEGIN
              WAIT 2           ;VCM001 time for intlk to clear
		GOSUB O8101K4 
;KER000		SA_MESSAGE = " "			;MLB007
		SA_2_MESSAGE = ""
		SA_3_MESSAGE = ""			
		LAMP GUSA_ADI, GUSA_ALARM, GREEN     ;MLB007
		END
   
	   IF AND('8101RF41':DEV_STAT,S_0) & ('8101PT711':AI_MEAS < 9.0) THEN
       GOSUB O8101RF41

;DWM00X
;KER000	   END                                                
;
	;-------------------------------------
	;	transition conditions
	;-------------------------------------
GU3TC:

	IF (SC_SA_OFF_CMD) THEN		;KER000
		GOTO GU4		;shutdown unloading


	;Check for any device failure.  Goto estop upon failure.
	IF !AND(GU_DIV_SEAL:DEV_STAT,S_1) THEN
		BEGIN
		WAIT 2	;MLB006 added 2 second wait for possible bouncing
		IF !AND(GU_DIV_SEAL:DEV_STAT,S_1) THEN	;MLB006
			BEGIN
;KER000			SA_MESSAGE = "8101Z1DS NOT SEALED"
			SA_2_MESSAGE = "8101Z1DS NOT SEALED"
			PRINT PRI_ADI, "%p",SA_2_MESSAGE
			GOTO ESTOP1
			END
		END
;
	IF !AND(SILO_DUST_VLV_PTR:DEV_STAT,S_1) THEN
		BEGIN
;KER000		SA_MESSAGE = "SILO DUST COLL VALVE NOT OPEN"
		SA_2_MESSAGE = "SILO DUST COLL VALVE NOT OPEN"
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		GOTO ESTOP1
		END

	;pbh002 IF (GRAIN_SEL_INT = MILLERMALT | GRAIN_SEL_INT = COORSMALT  | GRAIN_SEL_INT = MUNICHMALT) THEN
	IF (GRAIN_SEL_INT = MILLERMALT | GRAIN_SEL_INT = COORSMALT | GRAIN_SEL_INT = MUNICHMALT | GRAIN_SEL_INT = CHOCMALT | GRAIN_SEL_INT = CARA1030MALT ) THEN  ;pbh002 ADDED CHOCMALT AND CARA1030MALT
		BEGIN
;VCM009           IF !AND('8101XV51':DEV_STAT,S_1) THEN
;VCM009	      BEGIN
;VCM009	      SA_MSG = "VALVE 8101XV51 NOT IN POSITION"
;VCM009	      GOTO ESTOP1
;VCM009	      END 
		IF !AND(GU_SPENT_GRAIN_DUST_BLOWER:DEV_STAT,S_1) THEN			;MRP001
			BEGIN                                           
;KER000			SA_MESSAGE = "8101C33 BLOWER NOT RUNNING"
			SA_2_MESSAGE = "8101C33 BLOWER NOT RUNNING"
			PRINT PRI_ADI, "%p",SA_2_MESSAGE
			GOTO ESTOP1
			END
				 
		IF !AND('8101RF4':DEV_STAT,S_1) THEN
			BEGIN
;KER000			SA_MESSAGE = "8101RF4 AIRLCK NOT IN POSITION"
			SA_2_MESSAGE = "8101RF4 AIRLCK NOT IN POSITION"
			PRINT PRI_ADI, "%p",SA_2_MESSAGE
			GOTO ESTOP1
			END                                      
		END

	IF (GRAIN_SEL_INT = BLKMALT) | (GRAIN_SEL_INT = CARAMALT) THEN
	;ajw000	IF !AND('8101RF7':DEV_STAT,S_1) THEN
		IF !AND('8101RF4':DEV_STAT,S_1) THEN	  ;ajw000
			BEGIN
;KER000			SA_MESSAGE = "8101RF7 AIRLCK NOT IN POSITION"
		;ajw000	SA_2_MESSAGE = "8101RF7 AIRLCK NOT IN POSITION"
			SA_2_MESSAGE = "8101RF4 AIRLCK NOT IN POSITION"	;ajw000
			PRINT PRI_ADI, "%p",SA_2_MESSAGE
			GOTO ESTOP1
		;ajw000	IF (GRAIN_SEL_INT = BLKMALT) & !AND('8101XV71':DEV_STAT,S_1) THEN
		;ajw000		GOTO XV71ERR
            
		;ajw000	IF (GRAIN_SEL_INT = CARAMALT) & !AND('8101XV71':DEV_STAT,S_0) THEN
;ajw000XV71ERR:
		;ajw000		BEGIN 
;KER000				SA_MESSAGE = "8101XV71 VALVE NOT IN POSITION"
		;ajw000		SA_2_MESSAGE = "8101XV71 VALVE NOT IN POSITION"
		;ajw000		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		;ajw000		GOTO ESTOP1
		;ajw000		END
			END 
                                       
	IF !AND(DUSTCOLL_FAN_PTR:DEV_STAT,S_1) THEN
		BEGIN                                           
;KER000			SA_MESSAGE = "DUST COLLECTOR FAN NOT RUNNING"
		SA_2_MESSAGE = "DUST COLLECTOR FAN NOT RUNNING"
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		GOTO ESTOP1
		END                                           
;ldk001	IF (DUST_COLLECTOR_USE_PLANT_AIR = 0)THEN  ;VCMO11
;ldk001		BEGIN
;ldk001		IF !AND(PRGE_BLOWR_PTR:DEV_STAT,S_1) THEN
;ldk001   	   BEGIN                                           
;ldk001			SA_2_MESSAGE = "8101C22 BLOWER NOT RUNNING"
;ldk001			GOTO ESTOP1
;ldk001			END                                           
;ldk001		END 
					     
;ldk000	IF !AND(CLNR_DRV_PTR:DEV_STAT,S_1) THEN
	IF (GU_DUSTCOLL_PILOT_TIMER_VALVE_DOT:DOT_VAL = 0) THEN	;ldk000
		BEGIN                                           
;KER000			SA_MESSAGE = "DUST COLL DRIVE NOT RUNNING"
		SA_2_MESSAGE = "DUST COLL PVT NOT RUNNING"
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		GOTO ESTOP1
		END 
								
;                                        
	IF !AND(GU_PRESSURE_BLOWER:DEV_STAT,S_1) THEN
		BEGIN                                           
;KER000		SA_MESSAGE = "8101C12 BLOWER NOT RUNNING"
		SA_2_MESSAGE = "8101C12 BLOWER NOT RUNNING"
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		GOTO ESTOP1
		END                                           

	                                           

	IF !AND(GU_TRKHOP_DUST_ARLK:DEV_STAT,S_1) THEN
		BEGIN                                           
;KER000		SA_MESSAGE = "8101RF1 AIRLCK NOT IN POSITION"
		SA_2_MESSAGE = "8101RF1 AIRLCK NOT IN POSITION"
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		GOTO ESTOP1
		END                                               
;	
	IF !AND(GU_TRKHOP_DUST_FAN:DEV_STAT,S_1) THEN
		BEGIN                                           
;KER000		SA_MESSAGE = "8101C102 FAN NOT RUNNING"
		SA_2_MESSAGE = "8101C102 FAN NOT RUNNING"
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		GOTO ESTOP1
		END                                               
;	
;VCM010 	IF !AND('8101C101':DEV_STAT,S_1) THEN
;VCM010    	   BEGIN                                           
;VCM010 	   SA_MSG = "8101C101 BLOWER NOT RUNNING"
;VCM010 	   GOTO ESTOP1
;VCM010 	   END                                              
;	
;mrp003	IF !AND('8101SR101':DEV_STAT,S_1) THEN
;mrp003   	   BEGIN                                           
;mrp003	   SA_MSG = "8101SR101 DRIVE NOT RUNNING"
;mrp003	   GOTO ESTOP1
;mrp003	   END                                               
; 
;KER000
	SA_EX1_FG = !AND(GU_UNLOAD_RCVR_ARLK:DEV_STAT,S_1) 
	SA_EX2_FG = AND(GU_PRESSURE_BLOWER_HI:DEV_STAT,S_0)
	SA_EX3_FG = AND(GU_PRESSURE_BLOWER_LO:DEV_STAT,S_0)
	SA_EX4_FG = BLOWR_PRESSURE_FLAG = 0
	SA_EX5_FG = (AND(SILO_LVL_PTR:DEV_STAT,S_0) & AND(DUSTCOLL_HI_LVL_PTR:DEV_STAT,S_0))	;KER000 rotary valve is interlocked with high levels
		
	  
;KER000	IF !AND('8101RF41':DEV_STAT,S_1) THEN 
   IF (HI_HOP_LVL = 0)THEN     ;JMS001
      BEGIN							 ;JMS001
	IF (SA_EX1_FG & SA_EX2_FG & SA_EX3_FG & SA_EX4_FG & SA_EX5_FG) THEN	;KER00
		BEGIN                                           
;KER000		SA_MESSAGE = "8101RF41 AIRLK NOT IN POSITION"
		SA_2_MESSAGE = "8101RF41 AIRLK NOT IN POSITION"
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		GOTO ESTOP1
		END 
;   
	IF AND(GU_DRAG_CONVEYOR:DEV_DFLG,F_0) THEN
		BEGIN
;KER000		SA_MESSAGE = "8101K4 DRAG CONVEYOR FAULT"
		SA_2_MESSAGE = "8101K4 DRAG CONVEYOR FAULT"
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		GOTO ESTOP1
		END
		END     ;JMS001
	;Check levels
;KER000	IF (SILO_LVL_PTR:DIN_VAL = 0) THEN
	IF AND(SILO_LVL_PTR:DEV_STAT,S_1) THEN	;KER000 changed from din to dev
		BEGIN
;KER000		SA_MESSAGE = "SILO LEVEL HIGH"
		SA_2_MESSAGE = "SILO LEVEL HIGH"
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		WAIT 2		;time for interlock
		GOTO ESTOP1
		END
;KER000	IF AND('8101LH11':DEV_STAT,S_1) THEN
	IF AND(GU_TRKHOP_DUST_HI_LVL:DEV_STAT,S_1) THEN
		BEGIN
;KER000		SA_MESSAGE = "8101LSH11 LEVEL HIGH"
		SA_2_MESSAGE = "8101LSH11 LEVEL HIGH"
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		WAIT 2		;time for interlock
		GOTO ESTOP1
		END
;KER000 IF (DUSTCOLL_HI_LVL_PTR:DIN_VAL = 0) THEN
	IF AND(DUSTCOLL_HI_LVL_PTR:DEV_STAT,S_1) THEN ;KER000 changed from din to dev
		BEGIN
;KER000		SA_MESSAGE = "8101F4/F7 DUST COLL. LVL HI"              ;KAN004
		SA_2_MESSAGE = "8101F4/F7 DUST COLL. LVL HI"              ;KAN004
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		WAIT 2		;time for interlock
		GOTO ESTOP1
		END

	IF !AND(SILO_PROX_SWITCH:DEV_STAT,S_1) THEN 	;KER000	;selected silo high level switch
		BEGIN	
		SA_2_MESSAGE = "SILO PROX NOT MADE"              ;KAN004
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		GOTO ESTOP1
		END
;
	;Check for high pressure
;  	IF AND(GU_PRESSURE_BLOWER_HI:DEV_STAT,S_1) & (BLOWR_PRESSURE_FLAG = 0) THEN	
  	IF ('8101PT711':AI_MEAS > 9.0) & (BLOWR_PRESSURE_FLAG = 0) THEN	
		BEGIN
		TIMERCLR BLOWER_PRESSURE_TMR
		TIMERON BLOWER_PRESSURE_TMR
		BLOWR_PRESSURE_FLAG = 1
		SA_2_MESSAGE = "PT711 HI PSI TIMEOUT TMR ON"	;KER000 
		END 
                                                  
;  	IF AND(GU_PRESSURE_BLOWER_HI:DEV_STAT,S_0) & (BLOWR_PRESSURE_FLAG = 1) THEN	
  	IF ('8101PT711':AI_MEAS < 9.0) & (BLOWR_PRESSURE_FLAG = 1) THEN	
		BEGIN
		TIMEROFF BLOWER_PRESSURE_TMR
		TIMERCLR BLOWER_PRESSURE_TMR
		BLOWR_PRESSURE_FLAG = 0
;		WAIT 2
;		GOSUB C8101K4			;KER???	need to verify with site engineering
;		GOSUB O8101RF41		;KER???	need to verify with site engineering 
;		WAIT 2						;was not a restart on this equipment
;		GOSUB O8101K4			;KER???	need to verify with site engineering
;		GOSUB C8101RF41		;KER???	need to verify with site engineering 
;		SA_2_MESSAGE = ""
;      SA_3_MESSAGE = ""
		END

;	IF (BLOWER_PRESSURE_TMR <= MAX_BLOWER_PRESSURE_TIME & BLOWR_PRESSURE_FLAG = 1)  THEN
;		BEGIN
;		SA_TEMP_INT = MAX_BLOWER_PRESSURE_TIME - BLOWER_PRESSURE_TMR
;		SA_TEMP_INT2 = FLTCNV(SA_TMP_SG,SA_TEMP_INT,4,0)
;  	SA_TEMP_INT = APPEND(SA_3_MESSAGE,"HI PSI SD IN ",SA_TMP_SG," MORE SEC")
;		END
							  
	IF (BLOWER_PRESSURE_TMR >= MAX_BLOWER_PRESSURE_TIME) THEN	;15 sec
		BEGIN
;KER000		SA_MESSAGE = "8101PSH121 HI PRESSURE TIMEOUT"
		SA_2_MESSAGE = "8101PT711 HI PRESSURE TIMEOUT"
		PRINT PRI_ADI, "%p",SA_2_MESSAGE 
		GOTO ESTOP2
		END 
		 
;
	;Check for zero pressure
;VCMJJJ  	IF AND(GU_PRESSURE_BLOWER_LO:DEV_STAT,S_1) & (BLOWR_ZERO_PRESSURE_FLAG = 0) THEN	
  	IF ('8101PT711':AI_MEAS < 0.5) & (BLOWR_ZERO_PRESSURE_FLAG = 0) THEN	
		BEGIN
		TIMERCLR BLOWER_ZERO_PRESSURE_TMR
		TIMERON BLOWER_ZERO_PRESSURE_TMR
		BLOWR_ZERO_PRESSURE_FLAG = 1 
;		SA_2_MESSAGE = "PSL121 ZERO PSI TIMEOUT TMR ON"	;KER000
		SA_2_MESSAGE = "8101PT711 PSI TIMEOUT TMR ON"	;KER000
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		END  

  	IF ('8101PT711':AI_MEAS >= 0.5) THEN	;VCMJJJ
		BEGIN
		TIMEROFF BLOWER_ZERO_PRESSURE_TMR
		TIMERCLR BLOWER_ZERO_PRESSURE_TMR
		BLOWR_ZERO_PRESSURE_FLAG = 0
		END

                                                 
  	IF AND(GU_PRESSURE_BLOWER_LO:DEV_STAT,S_0) & (BLOWR_ZERO_PRESSURE_FLAG = 1) THEN	
		BEGIN
		TIMEROFF BLOWER_ZERO_PRESSURE_TMR
		TIMERCLR BLOWER_ZERO_PRESSURE_TMR
		BLOWR_ZERO_PRESSURE_FLAG = 0
		SA_2_MESSAGE = ""	;KER000
		SA_3_MESSAGE = ""
		END 

	IF (BLOWER_ZERO_PRESSURE_TMR <= MAX_BLOWER_ZERO_PRESSURE_TIME & BLOWR_ZERO_PRESSURE_FLAG = 1)  THEN
		BEGIN
		SA_TEMP_INT = MAX_BLOWER_ZERO_PRESSURE_TIME - BLOWER_ZERO_PRESSURE_TMR
		SA_TEMP_INT2 = FLTCNV(SA_TMP_SG,SA_TEMP_INT,4,0)
		SA_TEMP_INT = APPEND(SA_3_MESSAGE,"LO PSI SD IN ",SA_TMP_SG," MORE SEC")
		END
							 
	IF (BLOWER_ZERO_PRESSURE_TMR >= MAX_BLOWER_ZERO_PRESSURE_TIME) THEN 	;60 sec
		BEGIN
;KER000		SA_MESSAGE = "8101PSL121 ZERO PRESS TIMEOUT"
;VCMJJJ		SA_2_MESSAGE = "8101PSL121 ZERO PRESS TIMEOUT"
		SA_2_MESSAGE = "8101PT711 ZERO PRESS TIMEOUT"
		PRINT PRI_ADI, "%p",SA_2_MESSAGE 
		GOTO ESTOP2
		END         
;
	;Check hopper level and stop pushbutton
;KER000	IF ('8101LL441':DIN_VAL = 0) & (HOPPER_FLAG = 0) THEN
	IF (AUTO_SHUTDN) THEN
		BEGIN
		IF AND(GU_RAIL_PIT_LO_LVL:DEV_STAT,S_1) & (HOPPER_FLAG = 0) THEN		;KER000 din replaced with dev
			BEGIN
			SA_2_MESSAGE =  "RAIL PIT LO LVL TMR ON"	;KER000
			PRINT PRI_ADI, "%p",SA_2_MESSAGE
			TIMERCLR HOPPER_TMR
			TIMERON HOPPER_TMR
			HOPPER_FLAG = 1
			END
;KER000	IF ('8101LL441':DIN_VAL = 1) & (HOPPER_FLAG = 1) THEN
		IF AND(GU_RAIL_PIT_LO_LVL:DEV_STAT,S_0) & (HOPPER_FLAG = 1) THEN		;KER000 din replaced with dev
			BEGIN                                          
			TIMEROFF HOPPER_TMR
			TIMERCLR HOPPER_TMR
			HOPPER_FLAG = 0
			SA_2_MESSAGE = ""
			SA_3_MESSAGE = ""
			END

;VCM012
		IF (SILO_SEL_INT = SILO7) | (SILO_SEL_INT = SILO8) THEN			;carmel or black malt VCM012F
			BEGIN
			IF ((HOPPER_FLAG) & (HOPPER_TMR < 480)) THEN	;300 SEC			;KER000 operator will know how much time is left
				BEGIN
				SA_TEMP_INT = 480 - HOPPER_TMR
				SA_TEMP_INT2 = FLTCNV(SA_TMP_SG,SA_TEMP_INT,4,0)
				SA_TEMP_INT = APPEND(SA_3_MESSAGE,"LO PIT LVL SD IN ",SA_TMP_SG," MORE SEC")
				END
			IF (HOPPER_TMR >= 480)THEN
				BEGIN
				PRINT LOG_ADI,"SYSTEM UNLOADED FOR %i MINUTES",UNLOAD_TMR
				TIMEROFF HOPPER_TMR
				TIMERCLR HOPPER_TMR
				HOPPER_FLAG = 0
				GOTO GU4
				END
			END
		ELSE
			BEGIN
			IF ((HOPPER_FLAG) & (HOPPER_TMR < MAX_HOPPER_TIME)) THEN	;300 SEC			;KER000 operator will know how much time is left
				BEGIN
				SA_TEMP_INT = MAX_HOPPER_TIME - HOPPER_TMR
				SA_TEMP_INT2 = FLTCNV(SA_TMP_SG,SA_TEMP_INT,4,0)
				SA_TEMP_INT = APPEND(SA_3_MESSAGE,"LO PIT LVL SD IN ",SA_TMP_SG," MORE SEC")
				END
			IF (HOPPER_TMR >= MAX_HOPPER_TIME)THEN
				BEGIN
				PRINT LOG_ADI,"SYSTEM UNLOADED FOR %i MINUTES",UNLOAD_TMR
				TIMEROFF HOPPER_TMR
				TIMERCLR HOPPER_TMR
				HOPPER_FLAG = 0
				GOTO GU4
				END
         END                                               ;VCM004
;KER000	IF !AND('8101GU':DEV_TMP0,T_0)|((HOPPER_TMR >= MAX_HOPPER_TIME)&(AUTO_SHUTDN = 1))THEN
		END

	SA_EX1_FG = COMPAR(SA_2_MESSAGE,"RAIL PIT LO LVL TMR ON",22,EQ)	 
	SA_EX1_FG = (SA_EX1_FG & AUTO_SHUTDN = 0)					;clear out messages if operator cancelled auto shutdown

		IF (SA_EX1_FG) THEN
			BEGIN
			HOPPER_FLAG = 0
			TIMEROFF HOPPER_TMR
			TIMERCLR HOPPER_TMR
			SA_2_MESSAGE = ""
			SA_3_MESSAGE = ""
			PRINT PRI_ADI, "OPERATOR CANCELLED LO PIT LVL SD"
			END
				

	WAIT 1		;MLB008
	GOTO GU3SS
;

;===============================================================================
;		S H U T D O W N    U N L O A D I N G
;===============================================================================
;
;The shutdown unloading state is the fourth state of the grains unloading 
;process.  This state is transitioned into from the unloading state.
;
;The shutdown unloading state does the following:
;  * sets grains unloading status to shutdown
;  * stops drag conveyor 8101k4     
;  * stops the appropriate dust collector fans, blowers, drives and airlocks
;  * stops grains unloading blower 8101c12
; 	stops grain dust blower 8101C33				;mrp001
;  * sets grains unloading status to stopped
;  * updates silo inventory
;
;When all of the actions above have been completed, the process transitions
;to the idle and waiting state.
;
;If any device fails to close during this state, the process will transition
;to the failure state.
;                                                                              
GU4:	
	SA_STATUS = "SHUTDOWN UNLOADING"
	GU_STATE = 4
	SEQ_STATUS = ""
	SA_MESSAGE = ""
	SA_2_MESSAGE = ""
	SA_3_MESSAGE = ""
	SC_SA_OFF_CMD = 0		;KER000
	LAMP GUSA_ADI,GUSA_ALARM,GREEN
	PRINT LOG_ADI,"%p",SA_STATUS		;DWM001

	                            
;KER000	'8101GU':DEV_TMP1 = OR('8101GU':DEV_TMP1,T_27)     
;KER000	'8101GU':DEV_TMP1 = AND('8101GU':DEV_TMP1,NOT(T_25))
;KER000	'8101GU':DEV_TMP1 = AND('8101GU':DEV_TMP1,NOT(T_26)) 
;
	;---------------------------------------------
	;	command devices
	;---------------------------------------------
	IF AND(GU_DRAG_CONVEYOR:DEV_STAT,S_1) THEN		;KER000 only if running
		BEGIN
		GOSUB C8101K4
		END
	
	IF AND(GU_UNLOAD_RCVR_ARLK:DEV_STAT,S_1) THEN	;KER000 only if running
		BEGIN
		SA_MESSAGE = "1.5 MIN WAIT FOR RF41 AL STOP"
		WAIT ONE_AND_HALF_MINUTE	
		GOSUB C8101RF41
		END

	IF AND(GU_TRKHOP_DUST_ARLK:DEV_STAT,S_1) THEN	;KER000 only if running
		BEGIN
		SA_MESSAGE = "2 MIN WAIT FOR RF1 AL STOP"
		WAIT TWO_MINUTE	
		GOSUB C8101RF1
		END

	IF AND(GU_PRESSURE_BLOWER:DEV_STAT,S_1) THEN	;KER000 only if running
		BEGIN
		SA_MESSAGE = "1.5 MIN WAIT FOR C12 BL STOP"	      
		WAIT ONE_AND_HALF_MINUTE		
		GOSUB C8101C12
		END

	IF AND(DUSTCOLL_FAN_PTR:DEV_STAT,S_1) THEN	;KER000 only if running
		BEGIN
		SA_MESSAGE = "1 MIN WAIT FOR DC BLWER STOP"
		WAIT ONE_MINUTE	
		GOSUB CFAN
		END

;ldk000	IF AND(CLNR_DRV_PTR:DEV_STAT,S_1) THEN	;KER000 only if running
	IF (GU_DUSTCOLL_PILOT_TIMER_VALVE_DOT:DOT_VAL = 1) THEN		;ldk000
		BEGIN
		SA_MESSAGE = "1 MIN WAIT FOR DC CLNR STOP"	      
		WAIT ONE_MINUTE	
		GOSUB CDRIVE
		END

	IF AND(DUST_AIRLOCK_PTR:DEV_STAT,S_1) THEN	;KER000 only if running
		BEGIN
		SA_MESSAGE = "1 MIN WAIT FOR DC AIRLOCK STOP"		    
		WAIT ONE_MINUTE	
		GOSUB CAIRLOCK
		END

	SA_MESSAGE = ""
       GOSUB CRF4
	GOSUB C8101C33
;VCM009           GOSUB C8101XV51                                                     
                                                              
;KER000	'8101GU':DEV_TMP1 = OR('8101GU':DEV_TMP1,T_28) 
;KER000	'8101GU':DEV_TMP1 = AND('8101GU':DEV_TMP1,NOT(T_27))   
;KER000 removed from service per ICC	TURNOFF '8101PL81' 
;KER000 removed from service per ICC	TURNOFF '8101PL80'          
       SILO_INVENTORY_PTR:AI_INVL = SILO_INVENTORY_PTR:AI_INVL + GRAIN_WEIGHT
	SA_MESSAGE = "2 MIN WAIT FOR C102 BL STOP"
;	PRINT LOG_ADI, "GRAIN UNLOADING PT41 DP = %2.1f", '8101PT41':AI_MEAS  ;VCM014
	WAIT TWO_MINUTE	
	GOSUB C101C102
	SA_MESSAGE = "30 SEC WAIT FOR DUST VLV CLOSE"
	WAIT HALF_MINUTE
	GOSUB CDUSTVLV	;KER000 
;VCM010	GOSUB C101C101
;mrp003	GOSUB C8101SR101             
        GOTO GU1                 
;                                              

;===============================================================================
;		E S T O P    U N L O A D I N G
;===============================================================================
;
;The estop unloading state is the fifth state of the grains unloading process.
;This state is transitioned into from the idle and waiting, starting unloading,
;and unloading states.
;
;The estop unloading state does the following:
;  * turns on the horn
;  * sets grains unloading status to shutdown
;  * stops drag conveyor 8101k4     
;  * stops the appropriate dust collector fans, blowers, drives and airlocks
;  * stops grains unloading blower 8101c12
;	* stops grains dust blower 8101c33				;mrp001
;  * sets grains unloading status to stopped.
;
;When all of the actions above have been completed, the process transitions
;to the idle and waiting state.
;
;If any device fails to close during this state, the process will transition
;to the failure state.
;                                                                              
GU5:	
	SA_STATUS = "ESTOP UNLOADING"
	GU_STATE = 5
	SEQ_STATUS = ""
; adm000 begin 
;	LAMP GUSA_ADI,GUSA_ALARM,FLASH_RED                                     
	LAMP GUSA_ADI,GUSA_ALARM,RED 
; adm000 end          
	PRINT LOG_ADI,"%p",SA_STATUS		;DWM001
	PRINT LOG_ADI,"%p",SA_MESSAGE		;DWM001
;                                              
;KER000       '8101DO1':DEV_TMP1 = AND('8101DO1':DEV_TMP1,NOT(T_24))   
;KER000	'8101GU':DEV_TMP1 = OR('8101GU':DEV_TMP1,T_27)
;KER000	'8101GU':DEV_TMP1 = AND('8101GU':DEV_TMP1,NOT(T_25))
;KER000	'8101GU':DEV_TMP1 = AND('8101GU':DEV_TMP1,NOT(T_26)) 

	WAIT 1		;KER000 added to keep from failed to stop message
       IF AND(GU_UNLOAD_RCVR_ARLK:DEV_STAT,S_1) THEN	;if running
		BEGIN
		GOSUB C8101RF41
		END

	IF AND(GU_DRAG_CONVEYOR:DEV_STAT,S_1) THEN        ;if running
		BEGIN
		GOSUB C8101K4               
      K4_RUNNING = 0
		END
	;---------------------------------------------
	;	command devices
	;---------------------------------------------
;
   	IF (ESTOP_TYPE = 1) THEN
		BEGIN
		SA_MESSAGE = "1 MIN WAIT FOR ESTOP 1 START"	;MLB011
		WAIT ONE_MINUTE	
		GOSUB C101C102
;VCM010	   GOSUB C101C101
;mrp003	   GOSUB C8101SR101             

		IF AND(GU_TRKHOP_DUST_ARLK:DEV_STAT,S_1) THEN
			BEGIN
			SA_MESSAGE = "1 MIN WAIT FOR RF1 AL STOP"		;MLB011
			WAIT ONE_MINUTE	
			GOSUB C8101RF1             
			END

		IF AND(GU_PRESSURE_BLOWER:DEV_STAT,S_1) THEN
			BEGIN
			SA_MESSAGE = "1 MIN WAIT FOR C12 BLWER STOP"		;MLB011
			WAIT ONE_MINUTE	
			GOSUB C8101C12
			END

		IF AND(DUST_AIRLOCK_PTR:DEV_STAT,S_1) THEN
			BEGIN
			SA_MESSAGE = "1 MIN WAIT FOR DC AIRLOCK STOP"		    
			WAIT ONE_MINUTE	
			GOSUB CAIRLOCK
			SA_MESSAGE = ""
			END

		IF AND(GU_SPENT_GRAIN_DUST_BLOWER:DEV_STAT,S_1) THEN		;MRP001
			BEGIN
			SA_MESSAGE = "1 MIN WAIT FOR C33 BLWER STOP"		;Mrp001
			WAIT ONE_MINUTE	
			GOSUB C8101C33
			SA_MESSAGE = ""
			END
		END    

	IF (ESTOP_TYPE = 2) THEN
		BEGIN
		GOSUB C101C102
;VCM010	   GOSUB C101C101
;mrp003	   GOSUB C8101SR101             
		GOSUB C8101RF1             
		GOSUB C8101C12
;		GOSUB	C8101C33			;mrp001
		END

	IF AND(DUSTCOLL_FAN_PTR:DEV_STAT, S_1) THEN
		BEGIN
		SA_MESSAGE = "1 MIN WAIT FOR DC BLWER STOP"
		WAIT ONE_MINUTE	
		GOSUB CFAN
		END

	IF (GU_DUSTCOLL_PILOT_TIMER_VALVE_DOT:DOT_VAL = 1) THEN		;ldk000
		BEGIN
		SA_MESSAGE = "1 MIN WAIT FOR DC CLNR STOP"	      
		WAIT ONE_MINUTE	
;ldk001	GOSUB CBLOWER  ;VCMO11
		GOSUB CDRIVE
		END
	IF AND(DUST_AIRLOCK_PTR:DEV_STAT,S_1) THEN	;KER000 only if running
		BEGIN
		SA_MESSAGE = "1 MIN WAIT FOR DC AIRLOCK STOP"		    
		WAIT ONE_MINUTE	
		GOSUB CAIRLOCK
		SA_MESSAGE = ""
      GOSUB CRF4
;VCM009	   GOSUB C8101XV51
		END

		GOSUB C8101C33	;mrp001

	IF AND(SILO_DUST_VLV_PTR:DEV_STAT, S_1) THEN
		BEGIN
		SA_MESSAGE = "30 SEC WAIT FOR DUST VLV CLOSE"
		WAIT HALF_MINUTE	
		GOSUB CDUSTVLV	;KER000
		END
                                                              
;KER000	'8101GU':DEV_TMP1 = OR('8101GU':DEV_TMP1,T_28) 
;KER000	'8101GU':DEV_TMP1 = AND('8101GU':DEV_TMP1,NOT(T_27))  
;KER000 removed from service per ICC	TURNOFF '8101PL81'  
;KER000 removed from service per ICC	TURNOFF '8101PL80'          

;ldk001        IF (RUN_SPEC_MALT_DEV_FG = 1) THEN
;ldk001		BEGIN
;ldk001;ajw000		ASSIGN DEV_PTR = '8101RF7'         
;ldk001;ajw000		FAIL_MSG = "8101RF7 AIRLCK FAILED TO STOP"
;ldk001		ASSIGN DEV_PTR = '8101RF4'                 	;ajw000
;ldk001		FAIL_MSG = "8101RF4 AIRLCK FAILED TO STOP" 	;ajw000
;ldk001;KER000            GOSUB CLOSDEV
;ldk001		GOSUB CLOSDEV2				  

;ajw000		ASSIGN DEV_PTR = '8101C71'         
;ajw000		FAIL_MSG = "8101C71 FAN FAILED TO STOP"
;ldk000		ASSIGN DEV_PTR = '8101C41'               ;ajw000
;ldk000		FAIL_MSG = "8101C41 FAN FAILED TO STOP"  ;ajw000
;KER000	GOSUB CLOSDEV                              
;ldk000		GOSUB CLOSDEV2
;VCM008            ASSIGN DEV_PTR = '8101C72'            
;VCM008            FAIL_MSG = "8101C72 BLOWR FAILED TO STOP"
;VCM008            GOSUB CLOSDEV                              

;ajw000		ASSIGN DEV_PTR = '8101SR71'              
;ajw000		FAIL_MSG = "8101SR71 DRIVE FAILED TO STOP"
;ldk000		ASSIGN DEV_PTR = '8101SR41'                ;ajw000
;ldk000		FAIL_MSG = "8101SR41 DRIVE FAILED TO STOP" ;ajw000
;KER000	GOSUB CLOSDEV                              
;ldk000		GOSUB CLOSDEV2
;ldk001		TURNOFF GU_DUSTCOLL_PILOT_TIMER_VALVE_DOT	;8101PVT41	;ldk000
;ldk001		RUN_SPEC_MALT_DEV_FG = 0
;ldk001		END

        GOTO FAIL   ;KER000 WAS GU1                                                    
;                                                                               

;===============================================================================
;	RUN SPECIALITY MALT DEVICES DAILY      VCM004
;===============================================================================
;Run these devices everyday to prevent lockup 
GU6:	
	SA_STATUS = "RUN SPEC MALT DEVICES"
	GU_STATE = 6
	SEQ_STATUS = "" 
	SA_MESSAGE = ""			     
	SA_2_MESSAGE = ""									
	SA_3_MESSAGE = ""
; adm000 begin                                               
;	LAMP GUSA_ADI,GUSA_ALARM,FLASH_YEL
	LAMP GUSA_ADI,GUSA_ALARM,YELLOW
; adm000 end
	PRINT LOG_ADI,"%p",SA_STATUS 
;	PRINT LOG_ADI,"%p",SA_MSG    
;                                              
;	      ASSIGN DUST_AIRLOCK_PTR = '8101RF7'
;	      ASSIGN DUSTCOLL_FAN_PTR = '8101C71'
;	      ASSIGN PRGE_BLOWR_PTR = '8101C72'
;	      ASSIGN CLNR_DRV_PTR = '8101SR71' 
 

;ajw000 ASSIGN DEV_PTR = '8101RF7'
;ajw000	FAIL_MSG = "8101RF7 AIRLCK FAILED TO START"
	ASSIGN DEV_PTR = '8101RF4'            		 ;ajw000
	FAIL_MSG = "8101RF4 AIRLCK FAILED TO START" 	 ;ajw000
;KER000	GOSUB OPENDEV
	GOSUB OPENDEV2					      
;ajw000	ASSIGN DEV_PTR = '8101C71'
;ajw000	FAIL_MSG = "8101C71 FAN FAILED TO START"
	ASSIGN DEV_PTR = '8101C41'               ;ajw000
	FAIL_MSG = "8101C41 FAN FAILED TO START" ;ajw000
;KER000	GOSUB OPENDEV                              
	GOSUB OPENDEV2					      
;VCM008	ASSIGN DEV_PTR = '8101C72'
;VCM008	FAIL_MSG = "8101C72 BLOWR FAILED TO START"
;VCM008	GOSUB OPENDEV                              
;ajw000	ASSIGN DEV_PTR = '8101SR71'
;ajw000	FAIL_MSG = "8101SR71 DRIVE FAILED TO START"
;ldk000	ASSIGN DEV_PTR = '8101SR41'                
;ldk000	FAIL_MSG = "8101SR41 DRIVE FAILED TO START"
	FAIL_MSG = "8101PVT41 DRIVE FAILED TO START"			;ldk000
	TURNON GU_DUSTCOLL_PILOT_TIMER_VALVE_DOT	;8101PVT41	;ldk000
;KER000	GOSUB OPENDEV                              
;ldk000	GOSUB OPENDEV2					      

       TIMERON SPEC_MALT_TMR
GU6SS:

;KER000 added so operator will know how much time is left in state
	IF (SPEC_MALT_TMR < SPEC_MALT_TIME) THEN	;180 SEC
		BEGIN
		SA_TEMP_INT = SPEC_MALT_TIME - SPEC_MALT_TMR
		SA_TEMP_INT2 = FLTCNV(SA_TMP_SG,SA_TEMP_INT,4,0)
		SA_TEMP_INT = APPEND(SA_3_MESSAGE,"RUN SME FOR ",SA_TMP_SG," MORE SEC")
		END

;ajw000 IF !(AND('8101RF7':DEV_STAT,S_1)) THEN
	IF !(AND('8101RF4':DEV_STAT,S_1)) THEN	   ;ajw000
		BEGIN
;KER000		SA_MESSAGE = "8101RF7 AIRLOCK NOT ON"
	;ajw000	SA_2_MESSAGE = "8101RF7 AIRLOCK NOT ON"
		SA_2_MESSAGE = "8101RF4 AIRLOCK NOT ON"	;ajw000
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		GOTO FAIL
		END

;ajw000 IF !(AND('8101C71':DEV_STAT,S_1)) THEN
	IF !(AND('8101C41':DEV_STAT,S_1)) THEN	;ajw000
		BEGIN
;KER000		SA_MESSAGE = "8101C71 BLOWER NOT ON"
;ajw000		SA_2_MESSAGE = "8101C71 BLOWER NOT ON"
		SA_2_MESSAGE = "8101C41 BLOWER NOT ON"	;ajw000
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		GOTO FAIL
		END

;VCM008        IF !(AND('8101C72':DEV_STAT,S_1)) THEN
;VCM008           BEGIN
;VCM008           SA_MSG = "8101C72 BLOWER NOT ON"
;VCM008           GOTO FAIL
;VCM008           END

;ajw000 IF !(AND('8101SR71':DEV_STAT,S_1)) THEN
;ldk000	IF !(AND('8101SR41':DEV_STAT,S_1)) THEN	;ajw000
	IF (GU_DUSTCOLL_PILOT_TIMER_VALVE_DOT = 0) THEN	;ldk000
		BEGIN
;KER000		SA_MESSAGE = "8101SR71 CLEANER NOT ON"
;ajw000		SA_2_MESSAGE = "8101SR71 CLEANER NOT ON"
;ldk000		SA_2_MESSAGE = "8101SR41 CLEANER NOT ON"	;ajw000
		SA_2_MESSAGE = "8101PVT41 CLEANER NOT ON"	;ldk000
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		GOTO FAIL
		END

        ;======================================
        ; Transition conditions
        ;======================================

	IF (SPEC_MALT_TMR > SPEC_MALT_TIME) THEN
		BEGIN
		ASSIGN DEV_PTR = '8101RF7'         
;ajw000		FAIL_MSG = "8101RF7 AIRLCK FAILED TO STOP"
		FAIL_MSG = "8101RF4 AIRLCK FAILED TO STOP"	;ajw000
;KER000            GOSUB CLOSDEV
		GOSUB CLOSDEV2				  

;ajw000		ASSIGN DEV_PTR = '8101C71' 
		ASSIGN DEV_PTR = '8101C41' 	;ajw000	
		FAIL_MSG = "8101C71 FAN FAILED TO STOP" 
;KER000            GOSUB CLOSDEV                              
		GOSUB CLOSDEV2				  

;VCM008            ASSIGN DEV_PTR = '8101C72'            
;VCM008            FAIL_MSG = "8101C72 BLOWR FAILED TO STOP"
;VCM008            GOSUB CLOSDEV                              

;ajw000		ASSIGN DEV_PTR = '8101SR71'
;ldk000		ASSIGN DEV_PTR = '8101SR41'	;ajw000	      
;ldk000		FAIL_MSG = "8101SR71 DRIVE FAILED TO STOP"
;KER000            GOSUB CLOSDEV                              
;ldk000		GOSUB CLOSDEV2				  
		TURNOFF GU_DUSTCOLL_PILOT_TIMER_VALVE_DOT	;8101PVT41	;ldk000

		RUN_SPEC_MALT_DEV_FG = 0
		TIMEROFF SPEC_MALT_TMR
		TIMERCLR SPEC_MALT_TMR
		SA_2_MESSAGE = ""	;clear message
		SA_3_MESSAGE = ""	;clear message
		GOTO GU1	;KER000 VIC SAID RUN AUTO GU1TC
           END

        WAIT 1
        GOTO GU6SS


;===============================================================================
;		F A I L U R E
;===============================================================================
;
;The failure state is the sixth state of the grains unloading process.
;This state is transitioned into from the idle and waiting, unloading,
;shutdown unloading, and estop unloading states.
;
;The failure state turns on the horn.  It then waits until the horn has been
;reset by the operator and the start pushbutton has been depressed by the
;operator.  Then the process transitions back to the state that the process
;was in when the failure occurred.
;                                                                              
FAIL:
;DWM00x	SA_STATUS = "FAIL"
	SEQ_STATUS = "FAIL"
	SC_SA_CONT_CMD = 0
	SC_SA_START_CMD = 0
;MLB001
	FAIL_FLAG = 1

; adm000 begin 
;	LAMP GUSA_ADI,GUSA_ALARM,FLASH_RED                                     
	LAMP GUSA_ADI,GUSA_ALARM,RED 
; adm000 end          
;	PRINT LOG_ADI,"%p",SA_MSG		;DWM001
;	PRINT LOG_ADI,"%p",SA_STATUS		;DWM001
;KER000 

	STACKCLR

	IF (GU_STATE = 5) THEN	;came here from estop unloading
		GOTO FAILSS

;KER000 removed from service per ICC	TURNOFF '8101PL81'  
;KER000 removed from service per ICC	TURNOFF '8101PL80'   
;MLB011'8101DO1':DEV_TMP1 = AND('8101DO1':DEV_TMP1,NOT(T_24))
;DWM00x	WAIT 2
;MLB011

;KER000 removed	'8101DO1':DEV_TMP1 = AND('8101DO1':DEV_TMP1,NOT(T_24)) ;KER000
;	WAIT 5
;	'8101DO1':DEV_TMP1 = OR('8101DO1':DEV_TMP1,T_24)
		     
;                                              
;MLB001 if in a state beyond idle and waiting, shut everything that could 
;be on, off
	IF (GU_STATE > 1) THEN
		BEGIN
		GOSUB C101C102
;VCM010	   GOSUB C101C101
;mrp003	   GOSUB C8101SR101
		GOSUB C8101Z1M	;KER000 rotary diverter
		GOSUB C8101K4		;KER000 grain unloading drag conveyor
		GOSUB C8101RF41	;KER000 grain unloading receiver airlock	      
		GOSUB C8101RF1             
		GOSUB C8101C12       ;grain unloading pressure blower
;		GOSUB C8101C33	;mrp001

		SA_MESSAGE = "1 MIN WAIT FOR DC BL STOP"
		PRINT PRI_ADI, "%p",SA_MESSAGE
		WAIT ONE_MINUTE	
		GOSUB CFAN 
		SA_MESSAGE = "1 MIN WAIT FOR DC CLNR STOP"
		PRINT PRI_ADI, "%p",SA_MESSAGE	     
		WAIT ONE_MINUTE	
;ldk001	   GOSUB CBLOWER  ;VCMO11
		GOSUB CDRIVE
		SA_MESSAGE = "1 MIN WAIT FOR DC AIRLOCK STOP"
		PRINT PRI_ADI, "%p",SA_MESSAGE		    
		WAIT ONE_MINUTE	
		GOSUB CAIRLOCK 

		;pbh002IF (GRAIN_SEL_INT = MILLERMALT | GRAIN_SEL_INT = COORSMALT | GRAIN_SEL_INT = MUNICHMALT) THEN
		IF (GRAIN_SEL_INT = MILLERMALT | GRAIN_SEL_INT = COORSMALT | GRAIN_SEL_INT = MUNICHMALT | GRAIN_SEL_INT = CHOCMALT | GRAIN_SEL_INT = CARA1030MALT ) THEN  ;pbh002 ADDED CHOCMALT AND CARA1030MALT
			BEGIN
;KER000 removed duplicated with cairlock above 			GOSUB CRF4
			GOSUB C8101C33	;mrp001
;VCM009	      GOSUB C8101XV51
			END                                                    
		END
;MLB001
	;---------------------------------------------
	;	transition conditions
	;---------------------------------------------
FAILSS:
;
;KER000	WAITUNTIL AND('8101GU':DEV_TMP0,T_3) & AND('8101DO1':DEV_STAT,S_0)
	WAIT 2

	SA_MESSAGE = "WAITING FOR CONTINUE CMD"

	IF (SC_SA_CONT_CMD = 0) THEN
		GOTO FAILSS

	PRINT PRI_ADI, "%p",SA_MESSAGE

	

;KER000	WAITUNTIL AND('8101DO1':DEV_STAT,S_0)
;KER000 removed	GOSUB C8101DO1 
	WAIT 1				;MLB009
       FAIL_FLAG = 0
; adm000	IF (GU_STATE = 0) THEN	;maintenance wait
; adm000		GOTO ADST0
	GOTO GU1		;idle and waiting KER000
;MLB001
;	FAIL_FLAG = 0
;	IF (GU_STATE = 1) THEN
;           GOTO GU1                        
;	IF (GU_STATE = 2) THEN
;	   GOTO GU2
;	IF (GU_STATE = 3) THEN
;           GOTO GU3                        
;	IF (GU_STATE = 4) THEN
;           GOTO GU4               
;	IF (GU_STATE = 5) THEN
;           GOTO GU5               
;	IF (GU_STATE = 6) THEN
;           GOTO GU6         ;VCM004      
;                                

;*******************************************************************************
;
;	ERROR HANDLING SUBROUTINE
;
;*******************************************************************************
;
;
;
;	SC_ERROR_NUM:	Error number storage
;	SC_ERROR_LIN:	Error line storage
;
;
;	This subroutine handles any error problems resulting from the
;	execution of this program. Each error is handled in 3 different
;	ways. If the error is insignificant, it is ignored and the program
;	returns to rsume execution. If the error is significant but not
;	critical (valid), it is reported to printer and program continues
;	normal execution. If it is critical the program suspends execution
;	a message is printed to the printer, and SKD light is blinked.
;
;
;
;	List of specifically handled errors:
;
;	Error	Description				Type
;	-----	-----------				----
;	19	program already in kick subroutine	valid
;	32	undefined communications packet type	insignificant
;	41	pcm db header not loaded		insignificant
;	69	ipn not defined				insignificant
;       87      Holding program that is not running     critical
;	162	no such program this pcm		insignificant
;	165	sequence program already running	critical
;	170	serial number mismatch			critical
;	179	illegal subroutine			insignificant
;	187	could not be remote access		insignificant
;	193	no such program this pcm 		valid
;	198	illegal subroutine stack nesting	insignificant
;	199	illegal recipe data file		critical
;	200	recipe file not loaded inot memory	critical
;	201	recipe load not enabled			critical
;	222	boards dead				insignificant
;	226	board error				insignificant
;	245	both pcms down				insignificant
;
ERRSUB:	
	SC_ERROR_NUM = ABS(ERRNUM())
	SC_ERROR_LIN = ERRLIN()

;	if error insignificant , clear error and return to main code
	IF (SC_ERROR_NUM = 32) | (SC_ERROR_NUM = 41) | (SC_ERROR_NUM = 69) THEN
		ERSRET 			;return to program

	IF (SC_ERROR_NUM = 162) | (SC_ERROR_NUM = 179) | (SC_ERROR_NUM = 187) THEN
		ERSRET 			;return to program
	
	IF (SC_ERROR_NUM = 198) | (SC_ERROR_NUM = 222) | (SC_ERROR_NUM = 226) THEN
		ERSRET 			;return to program
	

	IF (SC_ERROR_NUM = 245) THEN
		ERSRET 			;return to program

;	if error is valid, print message, clear error, and return to program

	PRINT PRI_ADI, "*** ERROR %i AT LINE %i  ***",SC_ERROR_NUM,SC_ERROR_LIN
	IF (SC_ERROR_NUM = 193) | (SC_ERROR_NUM = 19) | (SC_ERROR_NUM = 251) THEN 
		ERSRET		;return to program

;	if error crtical, message has been printed, blink SKD light
;	wait for engineer to correct problem

	PRINT PRI_ADI, "** SABL PROG. FAILED NEED CORRECTIVE ACTION**"
	SA_MESSAGE = "GUSA PROGRAM FAILED"	;MLB012
	PRINT PRI_ADI, "%p",SA_MESSAGE
; adm000 begin 
;	LAMP CON_ADI,SABL_ALARM,FLASH_RED                                     
	LAMP CON_ADI,SABL_ALARM,RED 
; adm000 end          
	ERSCLR		;MLB012
	
	WAITUNTIL (0)
        LAMP CON_ADI,SABL_ALARM,BLACK
;MLB012	ERSRET
	EXIT		;MLB012

;MLB010
;===============================================================================
;		H O L D      I N T E R R U P T      S U B R O U T I N E
;===============================================================================
HOLDSUB:
	SEQ_STATUS = "HOLD"

; adm000 begin 
;	LAMP GUSA_ADI,GUSA_ALARM,FLASH_RED                                     
	LAMP GUSA_ADI,GUSA_ALARM,RED 
; adm000 end          
	PRINT LOG_ADI,"GUSA IN HOLD STATE"
	FAIL_FLAG = 1
	SC_SA_CONT_CMD = 0

	STACKCLR
	;-------------------------------------
	;	command devices
	;-------------------------------------
;KER000	removed        '8101DO1':DEV_TMP1 = AND('8101DO1':DEV_TMP1,NOT(T_24))
;	 WAIT 5
;	 '8101DO1':DEV_TMP1 = OR('8101DO1':DEV_TMP1,T_24)            
;                                              
;if in a state beyond idle and waiting, shut everything that could 
;be on, off
	IF (GU_STATE > 1) THEN
		BEGIN
		GOSUB C101C102
;VCM010	   GOSUB C101C101
;mrp003	   GOSUB C8101SR101             
		GOSUB C8101RF1             
		GOSUB C8101C12
;		GOSUB C8101C33			;MRP001
		SA_MESSAGE = "1 MIN WAIT FOR DC BL STOP"
		PRINT PRI_ADI, "%p",SA_MESSAGE	
		WAIT ONE_MINUTE	
		GOSUB CFAN
		SA_MESSAGE = "1 MIN WAIT FOR DC CLNR STOP"
		PRINT PRI_ADI, "%p",SA_MESSAGE	      
		WAIT ONE_MINUTE	
;ldk001	   GOSUB CBLOWER  ;VCMO11
		GOSUB CDRIVE
		SA_MESSAGE = "1 MIN WAIT FOR DC AL STOP"
		PRINT PRI_ADI, "%p",SA_MESSAGE		    
		WAIT ONE_MINUTE	
		GOSUB CAIRLOCK 

		;pbh002 IF (GRAIN_SEL_INT = MILLERMALT | GRAIN_SEL_INT = COORSMALT | GRAIN_SEL_INT = MUNICHMALT) THEN
		IF (GRAIN_SEL_INT = MILLERMALT | GRAIN_SEL_INT = COORSMALT | GRAIN_SEL_INT = MUNICHMALT | GRAIN_SEL_INT = CHOCMALT | GRAIN_SEL_INT = CARA1030MALT ) THEN  ;pbh002 ADDED CHOCMALT AND CARA1030MALT
			BEGIN
;KER000 removed duplicated with cairlock above			GOSUB CRF4
			GOSUB C8101C33	;mrp001
;VCM009	      GOSUB C8101XV51
			END                                                    
		END

	;-------------------------------------
	;	transition conditions
	;-------------------------------------
HOLDSS:
;KER000	WAITUNTIL AND('8101DO1':DEV_STAT,S_0)
	
	WAIT 2	

	SA_MESSAGE = "WAITING FOR CONTINUE CMD"

	IF (SC_SA_CONT_CMD = 0) THEN
		GOTO HOLDSS 

	HRSCLR		;MLB012
	SA_MESSAGE = ""	;MLB012


	FAIL_FLAG = 0

	IF (GU_STATE = 1) THEN	;idle and waiting
           GOTO GU1                        
	IF (GU_STATE = 2) THEN	;starting unloading
	   GOTO GU2
	IF (GU_STATE = 3) THEN	;unloading
		GOTO GU2		;starting unloading
;KER000           GOTO GU3                        
	IF (GU_STATE = 4) THEN	;shutdown unloading
           GOTO GU4               
	IF (GU_STATE = 5) THEN 	;estop unloading
		GOTO GU1		;idle and waiting
;KER000           GOTO GU5               
;mrp005	IF (GU_STATE = 6) THEN	;run speciality malt devices
;mrp005           GOTO GU6         ;VCM004

	GOTO GU1			;KER000      

;MLB010

;*******************************************************************************
;*******************************************************************************
;               S U B R O U T I N E S
;*******************************************************************************
;*******************************************************************************
;==============================================================================
;                       align device MAINTENANCE WAIT
;==============================================================================
ADST0:
	
;KER000	IF !(ALREADY_COMMANDED_FG) THEN
;KER000	    BEGIN        
;KER000	    SA_MESSAGE = "ALIGNING DEVICES MAINT WAIT"
;KER000	    END

;Transition strings
;KER000       IF (!TD_INTO1_FG) THEN
;KER000		BEGIN
;KER000		TR_TITLE_SG = "MW TO PROCESS WAIT"
;KER000		TR1_SG = "TO PROCESS WAIT"
;KER000		TR2_SG = "     SEQUENCE ENABLED"
;KER000		TR3_SG = "     PROCESS WAIT COMMAND"
;KER000		TD_INTO1_FG = 1
;KER000		END

;KER000	GOSUB xxxccciii 				;device name

;KER000	IF !(ALREADY_COMMANDED_FG) THEN
;KER000		BEGIN        
;KER000		SA_MESSAGE = ""
;KER000		PRINT LOG_ADI,"END ALIGN DEV in %p",SA_STATUS
;KER000		LAST_SA_STATE = SA_STATE		    
;KER000		END


;KER000	ALREADY_COMMANDED_FG = 1

MAINTDIVERTALIGN:

	WAIT 1

	;READY_UNLOAD = 0		;proceed to starting unloading step

	GOSUB C8101Z1DS			;assure seal is open, not sealed / C0
	PRINT LOG_ADI,"OPEN seal 1"	;MP2
	

	SA_EX1_FG = ('8101LS15':DIN_VAL = 0)		;divert drive not end left
	SA_EX2_FG = ('8101LS13':DIN_VAL = 0)		;divert drive not e-stop left
	SA_EX3_FG = (ROTARY_DIVERT_TRAV = 0)  		;rotary not beginning postioning 
	SA_EX4_FG = AND(SILO_PROX_SWITCH:DEV_STAT,S_0)	;selected silo prox not made

	IF (SA_EX1_FG & SA_EX2_FG & SA_EX3_FG & SA_EX4_FG) THEN       
		BEGIN
		SA_MESSAGE = "MAINT. REVERSING DIVERTER"
		PRINT PRI_ADI, "%p",SA_MESSAGE
		GOSUB O8101Z1M			;full reverse rotary diverter
		ROTARY_DIVERT_TRAV = 1		;rotary beginning postioning 
		END


	SA_EX1_FG = AND(SILO_PROX_SWITCH:DEV_STAT,S_1) ;selected silo prox made
	SA_EX2_FG = (AND('8101Z1M':DEV_STAT,S_0) | AND('8101Z1M':DEV_STAT,S_4))	      ;rotary diverter is off/inlk ;KER000 (ROTARY_DIVERT_TRAV = 0)     

	IF (SA_EX1_FG & SA_EX2_FG) THEN
		BEGIN
		SA_MESSAGE = "DIVERTER IS IN POSITION"
		PRINT PRI_ADI, "%p",SA_MESSAGE
		WAIT 1
		END

	SA_EX1_FG = ('8101LS15':DIN_VAL = 1)		;divert drive end left
	SA_EX1_FG = (SA_EX1_FG | ROTARY_DIVERT_TRAV)        	;rotary beginning postioning
	SA_EX2_FG = AND('8101Z1M':DEV_STAT,S_0)	;rotary diverter off
	SA_EX3_FG = ('8101LS16':DIN_VAL = 0)		;divert drive not end right
       SA_EX4_FG = ('8101LS14':DIN_VAL = 0)		;divert drive not e-stop right
	
	IF (SA_EX1_FG & SA_EX2_FG & SA_EX3_FG & SA_EX4_FG) THEN
		BEGIN
		DIVERTER_POSITION_FLAG = 0
		TIMEROFF SEARCH_DIV_POSITION_TMR
		TIMERCLR SEARCH_DIV_POSITION_TMR
		ROTARY_DIVERT_TRAV = 1             ;rotary beginning postioning
		GOSUB M8101Z1M			;command rotary diverter forward
		SA_MESSAGE = "MAINT. ALIGNING DIVERT TO SILO"
		PRINT PRI_ADI, "%p",SA_MESSAGE
		END

MAINTCKSILOSW:

	NOP

	SA_EX1_FG = (ROTARY_DIVERT_TRAV)        	;rotary beginning postioning		
	SA_EX2_FG = AND(SILO_PROX_SWITCH:DEV_STAT,S_1)	;selected silo prox made
	SA_EX3_FG = AND(GU_DIV_MOTOR:DEV_STAT,S_2)
	IF (SA_EX1_FG & SA_EX2_FG & SA_EX3_FG) THEN
		BEGIN
		GOSUB C8101Z1M			;stop the rotary diverter
		DIVERTER_POSITION_FLAG = 0
		ROTARY_DIVERT_TRAV = 0		;KER
		TIMEROFF SEARCH_DIV_POSITION_TMR
		TIMERCLR SEARCH_DIV_POSITION_TMR
		WAIT 1
		END

	
;ker start

	IF (DIVERTER_POSITION_FLAG = 0) THEN	
		BEGIN              
;KER000 start 
		SA_EX1_FG = AND('8101Z1M':DEV_STAT,S_1)
		SA_EX2_FG = AND('8101Z1M':DEV_STAT,S_2)

		IF (SA_EX1_FG | SA_EX2_FG) THEN   ;KER000 stop
			BEGIN				 
			DIVERTER_POSITION_FLAG = 1
			TIMERCLR SEARCH_DIV_POSITION_TMR
			TIMERON SEARCH_DIV_POSITION_TMR
			END
		END


	IF (SEARCH_DIV_POSITION_TMR > MAX_SRCH_TIME) THEN 	;Diverter not in position
			BEGIN
			TIMEROFF SEARCH_DIV_POSITION_TMR
			TIMERCLR SEARCH_DIV_POSITION_TMR
			GOSUB C8101Z1M		;stop the rotary diverter
			DIVERTER_POSITION_FLAG = 0	;reset flag
			SA_2_MESSAGE = "DIVERTER POSITIONING TIMEOUT"
			PRINT PRI_ADI, "%p",SA_MESSAGE 
			WAIT 5  
			RETCLR
			GOTO FAIL ;KER000 was GU1CD
			END

	SA_EX1_FG = AND('8101Z1M':DEV_STAT,S_1)          ;ROTARY diverter in reverse
	SA_EX2_FG = AND('8101Z1M':DEV_STAT,S_2)		;ROTARY diverter in forward

	IF (SA_EX1_FG | SA_EX2_FG) THEN	
		BEGIN
		GOTO MAINTCKSILOSW
		END

	

	RETURN
    
 
;===============================================================================
;		ASSIGN POINTERS PER GRAIN AND SILO SELECTIONS   KER000
;===============================================================================
CHECKGUSILOSEL: 
     ;Assign unloading pointers

	   ;Set pointers for malt and grits selections              
	;pbh002 IF ((GRAIN_SEL_INT = MILLERMALT)|(GRAIN_SEL_INT = COORSMALT)|(GRAIN_SEL_INT = MUNICHMALT)) THEN
		IF ((GRAIN_SEL_INT = MILLERMALT)|(GRAIN_SEL_INT = COORSMALT)|(GRAIN_SEL_INT = MUNICHMALT)|(GRAIN_SEL_INT = CHOCMALT)|(GRAIN_SEL_INT = CARA1030MALT)) THEN  ;pbh002 ADDED CHOCMALT AND CARA1030MALT
      BEGIN
		ASSIGN DUST_AIRLOCK_PTR = '8101RF4'
  	   ASSIGN DUSTCOLL_FAN_PTR = '8101C41'
;ldk001        ASSIGN PRGE_BLOWR_PTR = '8101C22'   ;VCMO11
;ldk000	      ASSIGN CLNR_DRV_PTR = '8101SR41'
;KER00	ASSIGN DUSTCOLL_HI_LVL_PTR = '8101LH41
		ASSIGN DUSTCOLL_HI_LVL_PTR = '8101LSH41'	;KER000 changed from din to dev  
	      ;Set pointers for malt selection
;		IF (GRAIN_SEL_INT = MILLERMALT) THEN
	;pbh002 IF ((GRAIN_SEL_INT = MILLERMALT)|(GRAIN_SEL_INT = COORSMALT)|(GRAIN_SEL_INT = MUNICHMALT)) THEN
	IF ((GRAIN_SEL_INT = MILLERMALT)|(GRAIN_SEL_INT = COORSMALT)|(GRAIN_SEL_INT = MUNICHMALT) |(GRAIN_SEL_INT = CHOCMALT)|(GRAIN_SEL_INT = CARA1030MALT)) THEN  ;pbh002 ADDED CHOCMALT AND CARA1030MALT
	       BEGIN
		IF (SILO_SEL_INT = SILO1) THEN			;silo m1
	              BEGIN
;KER000			ASSIGN SILO_LVL_PTR = '8102LH61'
			ASSIGN SILO_LVL_PTR = '8102LSH61'		;KER000 changed from din to dev
			ASSIGN SILO_DUST_VLV_PTR = '8101XV106'
			ASSIGN SILO_INVENTORY_PTR = '8102LI61'
			ASSIGN SILO_PROX_SWITCH = '8101ILS7'
			SILO_INDICATOR = 6
			SILO_SELECT_SG = "M1"			;KER000
			END                       
		IF (SILO_SEL_INT = SILO2) THEN		  	;silo m2
			BEGIN
;KER000			ASSIGN SILO_LVL_PTR = '8102LH51'
			ASSIGN SILO_LVL_PTR = '8102LSH51'		;KER000 changed from din to dev
			ASSIGN SILO_DUST_VLV_PTR = '8101XV105'
			ASSIGN SILO_INVENTORY_PTR = '8102LI51'
			ASSIGN SILO_PROX_SWITCH = '8101ILS8' 
			SILO_INDICATOR = 5
			SILO_SELECT_SG = "M2"                     ;KER000
			END                                          
		IF (SILO_SEL_INT = SILO3) THEN		      	;silo m3
			BEGIN
;KER000			ASSIGN SILO_LVL_PTR = '8102LH41'
			ASSIGN SILO_LVL_PTR = '8102LSH41'		;KER000 changed from din to dev
			ASSIGN SILO_DUST_VLV_PTR = '8101XV104'
			ASSIGN SILO_INVENTORY_PTR = '8102LI41'
			ASSIGN SILO_PROX_SWITCH = '8101ILS9'
			SILO_INDICATOR = 4
                     SILO_SELECT_SG = "M3"                     ;KER000
			END                                           
		IF (SILO_SEL_INT = SILO4) THEN			;silo m4		 ;mrp004
			BEGIN
;				SA_MESSAGE = "SILO 4 NOT AVAILABLE"					;MRP004
;				PRINT PRI_ADI, "%p",SA_MESSAGE						;MRP004			
;KER000			ASSIGN SILO_LVL_PTR = '8102LH31'
			ASSIGN SILO_LVL_PTR = '8102LSH31'		;KER000 changed from din to dev
			ASSIGN SILO_DUST_VLV_PTR = '8101XV103'
			ASSIGN SILO_INVENTORY_PTR = '8102LI31'                    
			ASSIGN SILO_PROX_SWITCH = '8101ILS10'
			SILO_INDICATOR = 3
                     SILO_SELECT_SG = "M4"			;KER000
			END                       
		IF (SILO_SEL_INT = SILO5) THEN	      		;silo m5
			BEGIN
;KER000			ASSIGN SILO_LVL_PTR = '8102LH21'
			ASSIGN SILO_LVL_PTR = '8102LSH21'		;KER000 changed from din to dev
			ASSIGN SILO_DUST_VLV_PTR = '8101XV102'
			ASSIGN SILO_INVENTORY_PTR = '8102LI21'
			ASSIGN SILO_PROX_SWITCH = '8101ILS11'
			SILO_INDICATOR = 2
                     SILO_SELECT_SG = "M5"                     ;KER000
			END                                           
		IF (SILO_SEL_INT = SILO6) THEN		 	;silo m6
			BEGIN
;KER000			ASSIGN SILO_LVL_PTR = '8102LH11'
			ASSIGN SILO_LVL_PTR = '8102LSH11'		;KER000 changed from din to dev
			ASSIGN SILO_DUST_VLV_PTR = '8101XV101'
			ASSIGN SILO_INVENTORY_PTR = '8102LI11'
			ASSIGN SILO_PROX_SWITCH = '8101ILS12'
			SILO_INDICATOR = 1
                     SILO_SELECT_SG = "M6"                     ;KER000
			END                                         
			GRAIN_WEIGHT = MALT_WEIGHT
			END                
;                                     
	      ;Set pointers for grits selection
;		IF (GRAIN_SEL_INT = G1_G4) THEN  ;VCM013
	;pbh002 IF ((GRAIN_SEL_INT = MILLERMALT)|(GRAIN_SEL_INT = COORSMALT)|(GRAIN_SEL_INT = MUNICHMALT)) THEN
		IF ((GRAIN_SEL_INT = MILLERMALT)|(GRAIN_SEL_INT = COORSMALT)|(GRAIN_SEL_INT = MUNICHMALT) |(GRAIN_SEL_INT = CHOCMALT)|(GRAIN_SEL_INT = CARA1030MALT)) THEN  ;pbh002 ADDED CHOCMALT AND CARA1030MALT
			BEGIN
		IF (SILO_SEL_INT = SILOG1) THEN		   	;silo g1
			BEGIN
;KER000			ASSIGN SILO_LVL_PTR = '8102LH91'
			ASSIGN SILO_LVL_PTR = '8102LSH91'		;KER000 changed from din to dev
			ASSIGN SILO_DUST_VLV_PTR = '8101XV109'
			ASSIGN SILO_INVENTORY_PTR = '8102LI91'
			ASSIGN SILO_PROX_SWITCH = '8101ILS3'
			SILO_INDICATOR = 9
         SILO_SELECT_SG = "G1"                     ;KER000
			END                       
		IF (SILO_SEL_INT = SILOG2) THEN			;silo g2
			BEGIN
;KER000			ASSIGN SILO_LVL_PTR = '8102LH101'
			ASSIGN SILO_LVL_PTR = '8102LSH101'		;KER000 changed from din to dev
			ASSIGN SILO_DUST_VLV_PTR = '8101XV110'
			ASSIGN SILO_INVENTORY_PTR = '8102LI101'
			ASSIGN SILO_PROX_SWITCH = '8101ILS4'
			SILO_INDICATOR = 10
                     SILO_SELECT_SG = "G2"                      ;KER000
			END                       
		IF (SILO_SEL_INT = SILOG3) THEN			;silo g3
			BEGIN
;KER000			ASSIGN SILO_LVL_PTR = '8102LH111'
			ASSIGN SILO_LVL_PTR = '8102LSH111'		;KER000 changed from din to dev
			ASSIGN SILO_DUST_VLV_PTR = '8101XV111'
			ASSIGN SILO_INVENTORY_PTR = '8102LI111' 
			ASSIGN SILO_PROX_SWITCH = '8101ILS5'
			SILO_INDICATOR = 11
                     SILO_SELECT_SG = "G3"                      ;KER000
			END                       
		IF (SILO_SEL_INT = SILOG4) THEN			;silo g4
			BEGIN
;KER000			ASSIGN SILO_LVL_PTR = '8102LH121'
			ASSIGN SILO_LVL_PTR = '8102LSH121'		;KER000 changed from din to dev
			ASSIGN SILO_DUST_VLV_PTR = '8101XV112'
			ASSIGN SILO_INVENTORY_PTR = '8102LI121'
			ASSIGN SILO_PROX_SWITCH = '8101ILS6'
			SILO_INDICATOR = 12
                     SILO_SELECT_SG = "G4"                     ;KER000
			END                       
		GRAIN_WEIGHT = GRTS_WEIGHT
		END                                    
		END                                                  


;	IF (GRAIN_SEL_INT = MUNICHMALT) THEN
;		BEGIN
;		IF (SILO_SEL_INT = SILOG1) THEN		   	;silo g1
;			BEGIN
;			ASSIGN SILO_LVL_PTR = '8102LSH91'		;KER000 changed from din to dev
;			ASSIGN SILO_DUST_VLV_PTR = '8101XV109'
;			ASSIGN SILO_INVENTORY_PTR = '8102LI91'
;			ASSIGN SILO_PROX_SWITCH = '8101ILS3'
;			SILO_INDICATOR = 9
;         SILO_SELECT_SG = "G1"                     ;KER000
;			END                       
;		GRAIN_WEIGHT = GRTS_WEIGHT
;		END                                    

;
	   ;Set pointers for black malt and caramel malt selections
	IF ((GRAIN_SEL_INT = BLKMALT) | (GRAIN_SEL_INT = CARAMALT)) THEN
              BEGIN
;MLB002
;MLB002
;mrp005		ASSIGN DUST_AIRLOCK_PTR = '8101RF7'
;mrp005		ASSIGN DUSTCOLL_FAN_PTR = '8101C71'

		ASSIGN DUST_AIRLOCK_PTR = '8101RF4'	;mrp005
		ASSIGN DUSTCOLL_FAN_PTR = '8101C41'	;mrp005

;VCM008	      	ASSIGN PRGE_BLOWR_PTR = '8101C72'
;mrp005		ASSIGN CLNR_DRV_PTR = '8101SR71'
;ldk000		ASSIGN CLNR_DRV_PTR = '8101SR41'	;mrp005
;KER000			ASSIGN DUSTCOLL_HI_LVL_PTR = '8101LH71'

;mrp005		ASSIGN DUSTCOLL_HI_LVL_PTR = '8101LSH71'	;KER000 changed from din to dev
		ASSIGN DUSTCOLL_HI_LVL_PTR = '8101LSH41'	;KER000 changed from din to dev	;mrp005
;
	      ;Set pointers for black malt selection

		IF (SILO_SEL_INT = SILO8) THEN			;silo m8
			BEGIN
;KER000			ASSIGN SILO_LVL_PTR = '8102LH81'
			ASSIGN SILO_LVL_PTR = '8102LSH81'		;KER000 changed from din to dev
			ASSIGN SILO_DUST_VLV_PTR = '8101XV108'
			ASSIGN SILO_INVENTORY_PTR = '8102LI81'
;KER000 replacing 			ASSIGN SILO_PROX_SWITCH = '8101ILS1'	;KER??? desc in cdband epn list reads this should be m7???
			ASSIGN SILO_PROX_SWITCH = '8101ILS2'	;ker changed to match pid icc epn address = q 6 1 9 1
			GRAIN_WEIGHT = BMLT_WEIGHT		
			SILO_INDICATOR = 8           
                     SILO_SELECT_SG = "M8"                     ;KER000
			END                                           
;
	      ;Set pointers for caramel malt selection
		IF (SILO_SEL_INT = SILO7) THEN			;silo m7
			BEGIN
;KER000			ASSIGN SILO_LVL_PTR = '8102LH71'
			ASSIGN SILO_LVL_PTR = '8102LSH71'		;KER000 changed from din to dev
			ASSIGN SILO_DUST_VLV_PTR = '8101XV107'
			ASSIGN SILO_INVENTORY_PTR = '8102LI71'
;KER000 replacing			ASSIGN SILO_PROX_SWITCH = '8101ILS2'	;KER??? desc in cdb and epn list reads this should be m8???
			ASSIGN SILO_PROX_SWITCH = '8101ILS1'    ;ker changed to match pid	icc epn address = q 6 1 9 2
			GRAIN_WEIGHT = CARA_WEIGHT              
			SILO_INDICATOR = 7
                     SILO_SELECT_SG = "M7"                      ;KER000
			END                                    
		END 

;KER000 IF (DUSTCOLL_HI_LVL_PTR:DIN_VAL = 0) THEN

	IF AND(SILO_LVL_PTR:DEV_STAT,S_1) THEN
		BEGIN
		SA_2_MESSAGE = "SELECTED SILO LEVEL HIGH"
		LEVEL_BAD_FG = 1	;stay steady state till good silo selection
		SA_MESSAGE = ""
		WAIT 1
		RETCLR
		GOTO GU1FT
		END
	ELSE	IF AND(DUSTCOLL_HI_LVL_PTR:DEV_STAT,S_1) THEN
			BEGIN
		;ajw000	SA_2_MESSAGE = "8101F4/F7 DUST COLL. LVL HI"             ;KAN004
			SA_2_MESSAGE = "8101F4 DUST COLL. LVL HI"	;ajw000
			LEVEL_BAD_FG = 1	;stay steady state till good silo selection
			SA_MESSAGE = ""
			WAIT 1
			RETCLR
			GOTO GU1FT
			END
	ELSE	IF AND(GU_TRKHOP_DUST_HI_LVL:DEV_STAT,S_1) THEN 
			BEGIN
			SA_2_MESSAGE = "8101LSH11 TRKHOP D.C. LVL HI"             ;KER000
			LEVEL_BAD_FG = 1	;stay steady state till good silo selection
			SA_MESSAGE = ""
			WAIT 1
			RETCLR
			GOTO GU1FT
			END 
	ELSE 
		BEGIN
		LEVEL_BAD_FG = 0
		IF COMPAR(SA_2_MESSAGE,"SELECTED SILO LEVEL HIGH",24,EQ) THEN
			SA_2_MESSAGE = ""
		END
	  
                          

	RETURN

 
;===============================================================================
;		CHECK THAT DEVICES ARE IN AUTO
;===============================================================================
CHECKAUTO:  

	IF !AND(GU_UNLOAD_RCVR_ARLK:DEV_MODE,M_0) THEN
		BEGIN
		SA_MESSAGE = "8101RF41 AIRLOCK NOT IN AUTO"
		PRINT PRI_ADI, "%p",SA_MESSAGE
		GOTO NOTAUTO                                     
		END                                               
	IF !AND(GU_TRKHOP_DUST_FAN:DEV_MODE,M_0) THEN
		BEGIN
		SA_MESSAGE = "8101C102 FAN NOT IN AUTO"
		PRINT PRI_ADI, "%p",SA_MESSAGE
		GOTO NOTAUTO                                     
		END                                               
;VCM010	IF !AND('8101C101':DEV_MODE,M_0) THEN
;VCM010	   BEGIN
;VCM010	   SA_MSG = "8101C101 BLOWER NOT IN AUTO"
;VCM010	   GOTO NOTAUTO                                     
;VCM010           END                                               
;mrp003	IF !AND('8101SR101':DEV_MODE,M_0) THEN									  
;mrp003	   BEGIN
;mrp003	   SA_MSG = "8101SR101 DRIVE NOT IN AUTO"
;mrp003	   GOTO NOTAUTO                                     
;mrp003           END                                               
	IF !AND(GU_DRAG_CONVEYOR:DEV_MODE,M_0) THEN
		BEGIN
		SA_MESSAGE = "8101K4 CONVEYOR NOT IN AUTO"
		PRINT PRI_ADI, "%p",SA_MESSAGE
		GOTO NOTAUTO                                     
		END                                               
	IF !AND(GU_TRKHOP_DUST_ARLK:DEV_MODE,M_0) THEN
		BEGIN
		SA_MESSAGE = "8101RF1 AIRLOCK NOT IN AUTO"
		PRINT PRI_ADI, "%p",SA_MESSAGE
		GOTO NOTAUTO                                     
		END                                               
	IF !AND(GU_PRESSURE_BLOWER:DEV_MODE,M_0) THEN
		BEGIN
		SA_MESSAGE = "8101C12 BLOWER NOT IN AUTO"
		PRINT PRI_ADI, "%p",SA_MESSAGE
		GOTO NOTAUTO                                     
		END 
	IF !AND(GU_SPENT_GRAIN_DUST_BLOWER:DEV_MODE,M_0) THEN		;mrp001
		BEGIN
		SA_MESSAGE = "8101C33 BLOWER NOT IN AUTO"
		PRINT PRI_ADI, "%p",SA_MESSAGE
		GOTO NOTAUTO                                     
		END											
	IF !AND(DUST_AIRLOCK_PTR:DEV_MODE,M_0) THEN
		BEGIN
		SA_MESSAGE = "DUST COLL AIRLOCK NOT IN AUTO"
		PRINT PRI_ADI, "%p",SA_MESSAGE
		GOTO NOTAUTO                                     
		END

	IF !AND(DUSTCOLL_FAN_PTR:DEV_MODE,M_0) THEN
		BEGIN
		SA_MESSAGE = "DUST COLLECTOR FAN NOT IN AUTO"
		PRINT PRI_ADI, "%p",SA_MESSAGE
		GOTO NOTAUTO                                     
		END
																	  
;ldk001	IF (DUST_COLLECTOR_USE_PLANT_AIR = 0)THEN  ;VCMO11
;ldk001		BEGIN
;ldk001		IF !AND(PRGE_BLOWR_PTR:DEV_MODE,M_0) THEN  ;VCMO11
;ldk001			BEGIN
;ldk001			SA_MESSAGE = "DUST COLL BLOWER NOT IN AUTO"
;ldk001			GOTO NOTAUTO                                     
;ldk001			END                                               
;ldk001		END
;ldk000	IF !AND(CLNR_DRV_PTR:DEV_MODE,M_0) THEN
;ldk000		BEGIN
;ldk000		SA_MESSAGE = "DUST COLL DRIVE NOT IN AUTO"
;ldk000		PRINT PRI_ADI, "%p",SA_MESSAGE
;ldk000		GOTO NOTAUTO                                     
;ldk000		END

  IF AND('8101Z1DS':DEV_MODE,M_2) THEN   ;VCMXXX
		BEGIN
		SA_2_MESSAGE = "8101Z1DS DIV SEAL OVERRIDE"
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		GOTO NOTAUTO                                     
		END

	IF !AND(GU_DIV_SEAL:DEV_MODE,M_0) THEN   ;KER000
		BEGIN
		SA_2_MESSAGE = "8101Z1DS DIV SEAL NOT IN AUTO"
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		GOTO NOTAUTO                                     
		END

	IF !AND('8101Z1M':DEV_MODE,M_0) THEN   ;KER000
		BEGIN
		SA_2_MESSAGE = "8101Z1M DIV. ROT. NOT IN AUTO"
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		GOTO NOTAUTO                                     
		END

	RETURN


NOTAUTO:
; adm000 begin                                               
;	LAMP GUSA_ADI,GUSA_ALARM,FLASH_YEL
	RETCLR
	LAMP GUSA_ADI,GUSA_ALARM,YELLOW
; adm000 end
	WAIT 2
	
	GOTO GU1	;KER000 was GU1FT
			;changed to gu1 to keep atop program till devices are in auto
 
;===============================================================================
;		CHECK GRAIN AND SILO SELECTIONS      
;===============================================================================
;KER000 added subroutine
CKGRAINSEL:

	; Check for valid grain selection
	ROTARY_DIVERT_TRAV = 0
	GRAINS_CHECK_OK_FLAG = 0
	SA_TEMP_INT = 1 ;VCM014
	WAIT 1
;VCM013  cHECK MALT TYPE SELECTION AGAINST SILO MALTTYPE STRING 
	IF (GRAIN_SEL_INT = MILLERMALT) THEN
		BEGIN
		IF (SILO_SEL_INT = SILO1)& (INSTR(M1_SILO_MALT_TYPE_SG_ALLOF0,"MILLER")) THEN
			BEGIN
			SA_TEMP_INT = M1_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO2)& (INSTR(M2_SILO_MALT_TYPE_SG_ALLOF0,"MILLER")) THEN
			BEGIN
			SA_TEMP_INT = M2_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO3)& (INSTR(M3_SILO_MALT_TYPE_SG_ALLOF0,"MILLER")) THEN
			BEGIN
			SA_TEMP_INT = M3_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO4)& (INSTR(M4_SILO_MALT_TYPE_SG_ALLOF0,"MILLER")) THEN
			BEGIN
			SA_TEMP_INT = M4_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO5)& (INSTR(M5_SILO_MALT_TYPE_SG_ALLOF0,"MILLER")) THEN
			BEGIN
			SA_TEMP_INT = M5_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO6)& (INSTR(M6_SILO_MALT_TYPE_SG_ALLOF0,"MILLER")) THEN
			BEGIN
			SA_TEMP_INT = M6_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILOG1)& (INSTR(G1_SILO_MALT_TYPE_SG_ALLOF0,"MILLER")) THEN
			BEGIN
			SA_TEMP_INT = G1_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILOG2)& (INSTR(G2_SILO_MALT_TYPE_SG_ALLOF0,"MILLER")) THEN
			BEGIN
			SA_TEMP_INT = G2_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILOG3)& (INSTR(G3_SILO_MALT_TYPE_SG_ALLOF0,"MILLER")) THEN
			BEGIN
			SA_TEMP_INT = G3_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILOG4)& (INSTR(G4_SILO_MALT_TYPE_SG_ALLOF0,"MILLER")) THEN
			BEGIN
			SA_TEMP_INT = G4_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		END

	IF (GRAIN_SEL_INT = COORSMALT) THEN
		BEGIN
		IF (SILO_SEL_INT = SILO1)& (INSTR(M1_SILO_MALT_TYPE_SG_ALLOF0,"COORS")) THEN
			BEGIN
			SA_TEMP_INT = M1_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO2)& (INSTR(M2_SILO_MALT_TYPE_SG_ALLOF0,"COORS")) THEN
			BEGIN
			SA_TEMP_INT = M2_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO3)& (INSTR(M3_SILO_MALT_TYPE_SG_ALLOF0,"COORS")) THEN
			BEGIN
			SA_TEMP_INT = M3_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO4)& (INSTR(M4_SILO_MALT_TYPE_SG_ALLOF0,"COORS")) THEN
			BEGIN
			SA_TEMP_INT = M4_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO5)& (INSTR(M5_SILO_MALT_TYPE_SG_ALLOF0,"COORS")) THEN
			BEGIN
			SA_TEMP_INT = M5_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO6)& (INSTR(M6_SILO_MALT_TYPE_SG_ALLOF0,"COORS")) THEN
			BEGIN
			SA_TEMP_INT = M6_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILOG1)& (INSTR(G1_SILO_MALT_TYPE_SG_ALLOF0,"COORS")) THEN
			BEGIN
			SA_TEMP_INT = G1_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILOG2)& (INSTR(G2_SILO_MALT_TYPE_SG_ALLOF0,"COORS")) THEN
			BEGIN
			SA_TEMP_INT = G2_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILOG3)& (INSTR(G3_SILO_MALT_TYPE_SG_ALLOF0,"COORS")) THEN
			BEGIN
			SA_TEMP_INT = G3_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILOG4)& (INSTR(G4_SILO_MALT_TYPE_SG_ALLOF0,"COORS")) THEN
			BEGIN
			SA_TEMP_INT = G4_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		END

	IF (GRAIN_SEL_INT = MUNICHMALT) THEN
		BEGIN
		IF (SILO_SEL_INT = SILO1)& (INSTR(M1_SILO_MALT_TYPE_SG_ALLOF0,"MUNICH")) THEN
			BEGIN
			SA_TEMP_INT = M1_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO2)& (INSTR(M2_SILO_MALT_TYPE_SG_ALLOF0,"MUNICH")) THEN
			BEGIN
			SA_TEMP_INT = M2_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO3)& (INSTR(M3_SILO_MALT_TYPE_SG_ALLOF0,"MUNICH")) THEN
			BEGIN
			SA_TEMP_INT = M3_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO4)& (INSTR(M4_SILO_MALT_TYPE_SG_ALLOF0,"MUNICH")) THEN
			BEGIN
			SA_TEMP_INT = M4_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO5)& (INSTR(M5_SILO_MALT_TYPE_SG_ALLOF0,"MUNICH")) THEN
			BEGIN
			SA_TEMP_INT = M5_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO6)& (INSTR(M6_SILO_MALT_TYPE_SG_ALLOF0,"MUNICH")) THEN
			BEGIN
			SA_TEMP_INT = M6_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILOG1)& (INSTR(G1_SILO_MALT_TYPE_SG_ALLOF0,"MUNICH")) THEN
			BEGIN
			SA_TEMP_INT = G1_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILOG2)& (INSTR(G2_SILO_MALT_TYPE_SG_ALLOF0,"MUNICH")) THEN
			BEGIN
			SA_TEMP_INT = G2_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILOG3)& (INSTR(G3_SILO_MALT_TYPE_SG_ALLOF0,"MUNICH")) THEN
			BEGIN
			SA_TEMP_INT = G3_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILOG4)& (INSTR(G4_SILO_MALT_TYPE_SG_ALLOF0,"MUNICH")) THEN
			BEGIN
			SA_TEMP_INT = G4_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		END
;pbh002 chocolate malt start
	IF (GRAIN_SEL_INT = CHOCMALT ) THEN
		BEGIN
		IF (SILO_SEL_INT = SILO1)& (INSTR(M1_SILO_MALT_TYPE_SG_ALLOF0,"CHOCMALT")) THEN
			BEGIN
			SA_TEMP_INT = M1_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO2)& (INSTR(M2_SILO_MALT_TYPE_SG_ALLOF0,"CHOCMALT")) THEN
			BEGIN
			SA_TEMP_INT = M2_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO3)& (INSTR(M3_SILO_MALT_TYPE_SG_ALLOF0,"CHOCMALT")) THEN
			BEGIN
			SA_TEMP_INT = M3_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO4)& (INSTR(M4_SILO_MALT_TYPE_SG_ALLOF0,"CHOCMALT")) THEN
			BEGIN
			SA_TEMP_INT = M4_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO5)& (INSTR(M5_SILO_MALT_TYPE_SG_ALLOF0,"CHOCMALT")) THEN
			BEGIN
			SA_TEMP_INT = M5_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO6)& (INSTR(M6_SILO_MALT_TYPE_SG_ALLOF0,"CHOCMALT")) THEN
			BEGIN
			SA_TEMP_INT = M6_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILOG1)& (INSTR(G1_SILO_MALT_TYPE_SG_ALLOF0,"CHOCMALT")) THEN
			BEGIN
			SA_TEMP_INT = G1_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILOG2)& (INSTR(G2_SILO_MALT_TYPE_SG_ALLOF0,"CHOCMALT")) THEN
			BEGIN
			SA_TEMP_INT = G2_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILOG3)& (INSTR(G3_SILO_MALT_TYPE_SG_ALLOF0,"CHOCMALT")) THEN
			BEGIN
			SA_TEMP_INT = G3_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILOG4)& (INSTR(G4_SILO_MALT_TYPE_SG_ALLOF0,"CHOCMALT")) THEN
			BEGIN
			SA_TEMP_INT = G4_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		END
;pbh002 chocolate malt end
;pbh002 CARAMEL 10/30 malt start
	IF (GRAIN_SEL_INT = CARA1030MALT ) THEN
		BEGIN
		IF (SILO_SEL_INT = SILO1)& (INSTR(M1_SILO_MALT_TYPE_SG_ALLOF0,"CARA1030MALT")) THEN
			BEGIN
			SA_TEMP_INT = M1_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO2)& (INSTR(M2_SILO_MALT_TYPE_SG_ALLOF0,"CARA1030MALT")) THEN
			BEGIN
			SA_TEMP_INT = M2_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO3)& (INSTR(M3_SILO_MALT_TYPE_SG_ALLOF0,"CARA1030MALT")) THEN
			BEGIN
			SA_TEMP_INT = M3_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO4)& (INSTR(M4_SILO_MALT_TYPE_SG_ALLOF0,"CARA1030MALT")) THEN
			BEGIN
			SA_TEMP_INT = M4_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO5)& (INSTR(M5_SILO_MALT_TYPE_SG_ALLOF0,"CARA1030MALT")) THEN
			BEGIN
			SA_TEMP_INT = M5_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILO6)& (INSTR(M6_SILO_MALT_TYPE_SG_ALLOF0,"CARA1030MALT")) THEN
			BEGIN
			SA_TEMP_INT = M6_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILOG1)& (INSTR(G1_SILO_MALT_TYPE_SG_ALLOF0,"CARA1030MALT")) THEN
			BEGIN
			SA_TEMP_INT = G1_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILOG2)& (INSTR(G2_SILO_MALT_TYPE_SG_ALLOF0,"CARA1030MALT")) THEN
			BEGIN
			SA_TEMP_INT = G2_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILOG3)& (INSTR(G3_SILO_MALT_TYPE_SG_ALLOF0,"CARA1030MALT")) THEN
			BEGIN
			SA_TEMP_INT = G3_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		IF (SILO_SEL_INT = SILOG4)& (INSTR(G4_SILO_MALT_TYPE_SG_ALLOF0,"CARA1030MALT")) THEN
			BEGIN
			SA_TEMP_INT = G4_SERVICE_INTEGER_ALLOF0
			IF (SA_TEMP_INT = 0) THEN
				GOTO GRAINNOMATCH
			GOTO GRAINMATCH
			END
		END
;pbh002 CARAMEL 10/30 malt end
		SA_EX1_FG = (GRAIN_SEL_INT != CARAMALT)&(GRAIN_SEL_INT != BLKMALT)
		IF SA_EX1_FG THEN
			GOTO GRAINNOMATCH  ;NO MATCH IF WE GOT HERE

GRAINMATCH:
;*************************************************************
;
;	CHECK IF GRAINS MISMATCH FOR GRAINS TYPE MALT 
;	AND
;	CHECK IF NEXT SILO IS FORWARD	
;*************************************************************	
;		SA_EX1_FG = (GRAIN_SEL_INT = MALT)			;good selection for grain type malt VCM013
		;pbh002 SA_EX1_FG = (GRAIN_SEL_INT = MILLERMALT)|(GRAIN_SEL_INT = COORSMALT)|(GRAIN_SEL_INT = MUNICHMALT);good selection for grain type malt
		SA_EX1_FG = (GRAIN_SEL_INT = MILLERMALT)|(GRAIN_SEL_INT = COORSMALT)|(GRAIN_SEL_INT = MUNICHMALT) |(GRAIN_SEL_INT = CHOCMALT) |(GRAIN_SEL_INT = CARA1030MALT) ;pbh002 ADDED CHOCMALT AND CARAMEL 10/30 BLEND MALT
		SA_EX2_FG = (SILO_SEL_INT >= SILO1)
		SA_EX3_FG = (SILO_SEL_INT <= SILO6)

		IF (SA_EX1_FG & SA_EX2_FG & SA_EX3_FG) THEN
			BEGIN
			SA_EX1_FG = AND(GU_SILO_PROX_M7:DEV_STAT,S_1)	
			SA_EX1_FG = (SA_EX1_FG | AND(GU_SILO_PROX_M8:DEV_STAT,S_1))	;M7 or M8 silo prox is made
			SA_EX1_FG = (SA_EX1_FG | AND(GU_SILO_PROX_G1:DEV_STAT,S_1) | AND(GU_SILO_PROX_G2:DEV_STAT,S_1))	;G1 or G2 silo prox is made
			SA_EX1_FG = (SA_EX1_FG | AND(GU_SILO_PROX_G3:DEV_STAT,S_1) | AND(GU_SILO_PROX_G4:DEV_STAT,S_1))	;G3 or G4 silo prox is made
			SA_EX2_FG = (SILO_SEL_INT >= SILO1)	        ;next silo is between M1 and M6
			SA_EX3_FG = (SILO_SEL_INT <= SILO6)	
		
			IF (SA_EX1_FG & SA_EX2_FG & SA_EX3_FG) THEN	;next silo selection in forward from position
				BEGIN
				ROTARY_DIVERT_TRAV = 1			;next silo is forward, avoid reverse of diverter
				END
			
			SA_EX1_FG = AND(GU_SILO_PROX_M1:DEV_STAT,S_1)	;M1 silo prox is made
			SA_EX2_FG = (SILO_SEL_INT >= SILO2)		;next silo is between M2 and M6
			SA_EX3_FG = (SILO_SEL_INT <= SILO6)	
		
			IF (SA_EX1_FG & SA_EX2_FG & SA_EX3_FG) THEN	;next silo selection in forward from position
				BEGIN
				ROTARY_DIVERT_TRAV = 1			;next silo is forward, avoid reverse of diverter
				END
			
			SA_EX1_FG = AND(GU_SILO_PROX_M2:DEV_STAT,S_1)	;M2 silo prox is made
			SA_EX2_FG = (SILO_SEL_INT >= SILO3)	        ;next silo is between M3 and M6
			SA_EX3_FG = (SILO_SEL_INT <= SILO6)	
		
			IF (SA_EX1_FG & SA_EX2_FG & SA_EX3_FG) THEN	;next silo selection in forward from position
				BEGIN
				ROTARY_DIVERT_TRAV = 1			;next silo is forward, avoid reverse of diverter
				END
			
			SA_EX1_FG = AND(GU_SILO_PROX_M3:DEV_STAT,S_1)	;M3 silo  prox is made
			SA_EX2_FG = (SILO_SEL_INT >= SILO4)	        ;next silo is between M4 and M6
			SA_EX3_FG = (SILO_SEL_INT <= SILO6)	
		
			IF (SA_EX1_FG & SA_EX2_FG & SA_EX3_FG) THEN	;next silo selection in forward from position
				BEGIN
				ROTARY_DIVERT_TRAV = 1			;next silo is forward, avoid reverse of diverter
				END
			
			SA_EX1_FG = AND(GU_SILO_PROX_M4:DEV_STAT,S_1)	;M4 silo prox is made
			SA_EX2_FG = (SILO_SEL_INT >= SILO5)	        ;next silo is between M5 or M6
			SA_EX3_FG = (SILO_SEL_INT <= SILO6)	
		
			IF (SA_EX1_FG & SA_EX2_FG & SA_EX3_FG) THEN	;next silo selection in forward from position
				BEGIN
				ROTARY_DIVERT_TRAV = 1			;next silo is forward, avoid reverse of diverter
				END
			
			SA_EX1_FG = AND(GU_SILO_PROX_M5:DEV_STAT,S_1)	;M5 silo prox is made
			SA_EX2_FG = (SILO_SEL_INT = SILO6)	        ;next silo is M6
		
			IF (SA_EX1_FG & SA_EX2_FG) THEN			;next silo selection in forward from position
				BEGIN
				ROTARY_DIVERT_TRAV = 1			;next silo is forward, avoid reverse of diverter
				END
			NOP
			GRAINS_CHECK_OK_FLAG = 1
			END
;*************************************************************
;
;	CHECK IF GRAINS MISMATCH FOR GRAINS TYPE MALT TO G1-G4
;	AND
;	CHECK IF NEXT SILO IS FORWARD	
;*************************************************************       	
;		SA_EX1_FG = (GRAIN_SEL_INT = G1_G4)			;good selection for grain type G1_G4 VCM013
		;pbh002 SA_EX1_FG = (GRAIN_SEL_INT = MILLERMALT)|(GRAIN_SEL_INT = COORSMALT)|(GRAIN_SEL_INT = MUNICHMALT);good selection for grain type malt
		SA_EX1_FG = (GRAIN_SEL_INT = MILLERMALT)|(GRAIN_SEL_INT = COORSMALT)|(GRAIN_SEL_INT = MUNICHMALT) |(GRAIN_SEL_INT = CHOCMALT) |(GRAIN_SEL_INT = CARA1030MALT) ;pbh002 ADDED CHOCMALT AND CARAMEL 10/30 BLEND MALT
		SA_EX2_FG = (SILO_SEL_INT >= SILOG1)
		SA_EX3_FG = (SILO_SEL_INT <= SILOG4)

		IF (SA_EX1_FG & SA_EX2_FG & SA_EX3_FG) THEN
			BEGIN
			SA_EX1_FG = AND(GU_SILO_PROX_M7:DEV_STAT,S_1)	
			SA_EX1_FG = (SA_EX1_FG | AND(GU_SILO_PROX_M8:DEV_STAT,S_1))	;M7 or M8 silo  prox is made
			SA_EX2_FG = (SILO_SEL_INT >= SILOG2)	        ;next silo is between G1 and G4
			SA_EX3_FG = (SILO_SEL_INT <= SILOG4)	
		
			IF (SA_EX1_FG & SA_EX2_FG & SA_EX3_FG) THEN	;next silo selection in forward from position
				BEGIN
				ROTARY_DIVERT_TRAV = 1			;next silo is forward, avoid reverse of diverter
				END
			
			SA_EX1_FG = AND(GU_SILO_PROX_G1:DEV_STAT,S_1)	;G1 silo prox is made
			SA_EX2_FG = (SILO_SEL_INT = SILOG2)	        ;next silo is between G2 and G4
			SA_EX3_FG = (SILO_SEL_INT <= SILOG4)	
		
			IF (SA_EX1_FG & SA_EX2_FG & SA_EX3_FG) THEN	;next silo selection in forward from position
				BEGIN
				ROTARY_DIVERT_TRAV = 1			;next silo is forward, avoid reverse of diverter
				END
			
			SA_EX1_FG = AND(GU_SILO_PROX_G2:DEV_STAT,S_1)	;G2 silo prox is made
			SA_EX2_FG = (SILO_SEL_INT >= SILOG3)	        ;next silo is between G3 or G4
			SA_EX3_FG = (SILO_SEL_INT <= SILOG4)	
		
			IF (SA_EX1_FG & SA_EX2_FG & SA_EX3_FG) THEN	;next silo selection in forward from position
				BEGIN
				ROTARY_DIVERT_TRAV = 1			;next silo is forward, avoid reverse of diverter
				END
			
			SA_EX1_FG = AND(GU_SILO_PROX_G3:DEV_STAT,S_1)	;G3 silo prox is made
			SA_EX2_FG = (SILO_SEL_INT = SILOG4)	        ;next silo is G4
		
			IF (SA_EX1_FG & SA_EX2_FG) THEN			;next silo selection in forward from position
				BEGIN
				ROTARY_DIVERT_TRAV = 1			;next silo is forward, avoid reverse of diverter
				END
			NOP
			GRAINS_CHECK_OK_FLAG = 1  
			END
;*************************************************************
;
;	CHECK IF GRAINS MISMATCH FOR GRAINS TYPE BLACK MALT
;	AND
;	CHECK IF NEXT SILO IS FORWARD	
;*************************************************************	      

		SA_EX1_FG = (GRAIN_SEL_INT = BLKMALT)			;good selection for grain type BLKMALT
		SA_EX2_FG = (SILO_SEL_INT = SILO8)

		IF (SA_EX1_FG & SA_EX2_FG) THEN
			BEGIN
			SA_EX1_FG = AND(GU_SILO_PROX_M7:DEV_STAT,S_1)	;M7 silo prox is made
			SA_EX2_FG = (SILO_SEL_INT = SILO8)	        ;next silo is M8
		
			IF (SA_EX1_FG & SA_EX2_FG) THEN			;next silo selection in forward from position
				BEGIN
				ROTARY_DIVERT_TRAV = 1			;next silo is forward, avoid reverse of diverter
				END
			NOP
			GRAINS_CHECK_OK_FLAG = 1  
			END
;*************************************************************
;
;	CHECK IF GRAINS MISMATCH FOR GRAINS TYPE CARAMALT
;
;*************************************************************
		SA_EX1_FG = (GRAIN_SEL_INT = CARAMALT)			;good selection for grain type CARAMALT
		SA_EX2_FG = (SILO_SEL_INT = SILO7)

		IF (SA_EX1_FG & SA_EX2_FG) THEN
			BEGIN
			GRAINS_CHECK_OK_FLAG = 1  
			END 
	
;*************************************************************
;
;	CHECK IF GRAINS MISMATCH FOR GRAINS TYPE MUNICH
;
;*************************************************************
;VCM013		SA_EX1_FG = (GRAIN_SEL_INT = MUNICHMALT)			;good selection for grain type CARAMALT
;VCM013		SA_EX2_FG = (SILO_SEL_INT = SILOG1)

;VCM013		IF (SA_EX1_FG & SA_EX2_FG) THEN
;VCM013			BEGIN
;VCM013			GRAINS_CHECK_OK_FLAG = 1  
;VCM013			END 
	
GRAINNOMATCH:		;VCM013
	NOP

	;Check grains type
	IF (GRAINS_CHECK_OK_FLAG = 0) & (COMPAR(SA_MESSAGE,"GRAINS/SILO MISMATCH",20,NE)) THEN
		BEGIN
		IF (SA_TEMP_INT = 0) THEN
			SA_MESSAGE = "SILO OUT OF SERVICE"
		  ELSE
			SA_MESSAGE = "GRAINS/SILO MISMATCH"
		GRAIN_SILO_LOCK_FG = 0		;KEROOO unlock selection
		PRINT PRI_ADI, "%p",SA_MESSAGE
		END
	ELSE
		BEGIN
		LAMP GUSA_ADI,GUSA_ALARM,GREEN
		END

	NOP

	RETURN
	 

 
;===============================================================================
;		ALIGN DUST VALVES    
;===============================================================================

ADST1:
;open and close dust collector valves
	
	SA_MESSAGE = "ALIGNING VALVES"
	WAIT 2

	ASSIGN DEV_PTR = SILO_DUST_VLV_PTR
	FAIL_MSG = "SILO DSTCOL VLV FAILED TO OPEN"
	GOSUB OPENDEV3
;
	IF (SILO_INDICATOR != 1) THEN
		BEGIN
		ASSIGN DEV_PTR = '8101XV101'
		FAIL_MSG = "8101XV101 FAILED TO CLOSE"
		GOSUB CLOSDEV3
		END
;                                                            
	IF (SILO_INDICATOR != 2) THEN
		BEGIN
		ASSIGN DEV_PTR = '8101XV102'
		FAIL_MSG = "8101XV102 FAILED TO CLOSE"	
		GOSUB CLOSDEV3
		END
;                                                            
	IF (SILO_INDICATOR != 3) THEN
	      BEGIN
	      ASSIGN DEV_PTR = '8101XV103'
	      FAIL_MSG = "8101XV103 FAILED TO CLOSE"
	      GOSUB CLOSDEV3
	      END
;                                                            
	   IF (SILO_INDICATOR != 4) THEN
	      BEGIN
	      ASSIGN DEV_PTR = '8101XV104'
	      FAIL_MSG = "8101XV104 FAILED TO CLOSE"
	      GOSUB CLOSDEV3
	      END
;                                                            
	   IF (SILO_INDICATOR != 5) THEN
	      BEGIN
	      ASSIGN DEV_PTR = '8101XV105'
	      FAIL_MSG = "8101XV105 FAILED TO CLOSE"
	      GOSUB CLOSDEV3
	      END
;                                                            
	   IF (SILO_INDICATOR != 6) THEN
	      BEGIN
	      ASSIGN DEV_PTR = '8101XV106'
	      FAIL_MSG = "8101XV106 FAILED TO CLOSE"
	      GOSUB CLOSDEV3
	      END
;                                                            
	   IF (SILO_INDICATOR != 7) THEN
	      BEGIN
	      ASSIGN DEV_PTR = '8101XV107'
	      FAIL_MSG = "8101XV107 FAILED TO CLOSE"
	      GOSUB CLOSDEV3
	      END
;                                                            
	   IF (SILO_INDICATOR != 8) THEN
	      BEGIN
	      ASSIGN DEV_PTR = '8101XV108'
	      FAIL_MSG = "8101XV108 FAILED TO CLOSE"
	      GOSUB CLOSDEV3
	      END
;                                                            
	   IF (SILO_INDICATOR != 9) THEN
	      BEGIN
	      ASSIGN DEV_PTR = '8101XV109'
	      FAIL_MSG = "8101XV109 FAILED TO CLOSE"
	      GOSUB CLOSDEV3
	      END
;                                                            
	   IF (SILO_INDICATOR != 10) THEN
	      BEGIN
	      ASSIGN DEV_PTR = '8101XV110'
	      FAIL_MSG = "8101XV110 FAILED TO CLOSE"
	      GOSUB CLOSDEV3
	      END
;                                                            
	   IF (SILO_INDICATOR != 11) THEN
	      BEGIN
	      ASSIGN DEV_PTR = '8101XV111'
	      FAIL_MSG = "8101XV111 FAILED TO CLOSE"
	      GOSUB CLOSDEV3
	      END
;                                                            
	   IF (SILO_INDICATOR != 12) THEN
	      BEGIN
	      ASSIGN DEV_PTR = '8101XV112'
	      FAIL_MSG = "8101XV112 FAILED TO CLOSE"
	      GOSUB CLOSDEV3
	      END

;KER000	caramalt - black malt valve alignment
;mrp005 start

	IF (GRAIN_SEL_INT = BLKMALT) | (GRAIN_SEL_INT = CARAMALT) THEN
		BEGIN
	;ajw000	IF (SILO_SEL_INT = SILO8) THEN
	;ajw000		BEGIN
	;ajw000       	IF (AND( '8101XV71':DEV_DFLG,F_0) | AND( '8101XV71':DEV_STAT,S_4)) THEN
	;ajw000			GOTO XV71FLT
	;ajw000		IF AND( '8101XV71':DEV_STAT,S_1) THEN
	;ajw000			GOTO XV71OK
	;ajw000		IF !AND( '8101XV71':DEV_MODE,M_0) THEN
	;ajw000			BEGIN
;KER000				SA_MESSAGE = "DEVICE NOT IN AUTO"
	;ajw000			SA_2_MESSAGE = "8101XV71 NOT IN AUTO"
	;ajw000			PRINT PRI_ADI, "%p",SA_2_MESSAGE
	;ajw000			GOTO FAIL
	;ajw000			END                                       
;KER000		'8101XV71':DEV_TMP1 = OR( '8101XV71':DEV_TMP1,T_26)   
	;ajw000		GOSUB O8101XV71	;KER000 added for new mdv
	;ajw000		WAITUNTIL (AND( '8101XV71':DEV_STAT,S_1) | AND('8101XV71':DEV_DFLG,F_0)) COUNT 60,XV71FLT
	;ajw000		IF AND( '8101XV71':DEV_DFLG,F_0)  THEN
	;ajw000			BEGIN
;ajw000XV71FLT:         		;KER000 SA_MESSAGE = "8101XV71 TO BLACK MALT FAILED"
	;ajw000			SA_2_MESSAGE = "8101XV71 TO BLACK MALT FAILED"
	;ajw000			PRINT PRI_ADI, "%p",SA_2_MESSAGE	
	;ajw000			GOTO FAIL
	;ajw000			END
	;ajw000		END                                                               
	;ajw000	ELSE
	;ajw000		BEGIN
	;ajw000		ASSIGN DEV_PTR = '8101XV71'
	;ajw000		FAIL_MSG = "8101XV71 TO CARAMEL MLT FAILED"
;KER000		GOSUB CLOSDEV
	;ajw000		GOSUB CLOSDEV2
	;ajw000		WAIT 2 ;KER000 	;timer for inlk to clear on airlock
	;ajw000		END 
		END  
;ajw000XV71OK:

;	mrp005 end

	WAIT 2

	RETURN

 
;===============================================================================
;		ALIGN DIVERTER TO PROPER SILO, CHECK POSITION TIMER AND SEAL 
;===============================================================================
ALIGNDIVERTER:

	WAIT 1

	READY_UNLOAD = 0		;proceed to starting unloading step

	;GOSUB C8101Z1DS			;assure seal is open, not sealed / C0

	SA_EX1_FG = ('8101LS15':DIN_VAL = 0)		;divert drive not end left
	SA_EX2_FG = ('8101LS13':DIN_VAL = 0)		;divert drive not e-stop left
	SA_EX3_FG = (ROTARY_DIVERT_TRAV = 0)  		;rotary not beginning postioning 
	SA_EX4_FG = AND(SILO_PROX_SWITCH:DEV_STAT,S_0)	;selected silo prox not made

	IF (SA_EX1_FG & SA_EX2_FG & SA_EX3_FG & SA_EX4_FG) THEN       
		BEGIN
		IF AND(GU_DIV_SEAL:DEV_STAT,S_1) THEN		;seal is sealed
			BEGIN
			GOSUB C8101Z1DS				;open the seal 
			PRINT LOG_ADI,"OPEN seal 2"		;mp2
			WAIT 2
			END
		SA_MESSAGE = "REVERSING DIVERTER"
		PRINT PRI_ADI, "%p",SA_MESSAGE
		GOSUB O8101Z1M			;full reverse rotary diverter
		ROTARY_DIVERT_TRAV = 1		;rotary beginning postioning 
		END


	SA_EX1_FG = AND(SILO_PROX_SWITCH:DEV_STAT,S_1) ;selected silo prox made
	SA_EX2_FG = (AND('8101Z1M':DEV_STAT,S_0) | AND('8101Z1M':DEV_STAT,S_4))	      ;rotary diverter is off/inlk ;KER000 (ROTARY_DIVERT_TRAV = 0)     
	SA_EX3_FG = ((READY_SEAL = 0) |AND(GU_DIV_SEAL:DEV_STAT,S_1))

	IF (SA_EX1_FG & SA_EX2_FG & SA_EX3_FG) THEN
		BEGIN
		SA_MESSAGE = "DIVERTER IS IN POSITION UNLOAD"
		PRINT PRI_ADI, "%p",SA_MESSAGE
		READY_SEAL = 1                   	;allow rotary diverter head to seal
		WAIT 3
		END

	SA_EX1_FG = ('8101LS15':DIN_VAL = 1)		;divert drive end left
	SA_EX1_FG = (SA_EX1_FG | ROTARY_DIVERT_TRAV)        	;rotary beginning postioning
	SA_EX2_FG = (AND('8101Z1M':DEV_STAT,S_0) | AND('8101Z1M':DEV_STAT,S_4))	;rotary diverter off or interlocked
	SA_EX3_FG = ('8101LS16':DIN_VAL = 0)		;divert drive not end right
   SA_EX4_FG = ('8101LS14':DIN_VAL = 0)		;divert drive not e-stop right
	
	IF (SA_EX1_FG & SA_EX2_FG & SA_EX3_FG & SA_EX4_FG) THEN
		BEGIN
		IF AND(GU_DIV_SEAL:DEV_STAT,S_1) THEN		;seal is sealed
			BEGIN
			GOSUB C8101Z1DS				;open the seal
			PRINT LOG_ADI,"OPEN seal 3" ;mp2
			WAIT 2
			END
		DIVERTER_POSITION_FLAG = 0
		TIMEROFF SEARCH_DIV_POSITION_TMR
		ROTARY_DIVERT_TRAV = 1             ;rotary beginning postioning
		GOSUB M8101Z1M			;command rotary diverter forward
		SA_MESSAGE = "ALIGNING DIVERTER TO SILO"
		PRINT PRI_ADI, "%p",SA_MESSAGE
		END

CKSILOSW:
	NOP

	SA_EX1_FG = (ROTARY_DIVERT_TRAV)        	;rotary beginning postioning		
	SA_EX2_FG = AND(SILO_PROX_SWITCH:DEV_STAT,S_1)	;selected silo prox made
   SA_EX3_FG = AND(GU_DIV_MOTOR:DEV_STAT,S_2)
	IF (SA_EX1_FG & SA_EX2_FG & SA_EX3_FG) THEN
		BEGIN
		READY_SEAL = 1			;allow rotary diverter head to seal
		GOSUB C8101Z1M			;stop the rotary diverter
		DIVERTER_POSITION_FLAG = 0
		TIMEROFF SEARCH_DIV_POSITION_TMR
		END

	
;ker start

	IF (DIVERTER_POSITION_FLAG = 0) THEN	
		BEGIN              
;KER000 start 
		SA_EX1_FG = AND('8101Z1M':DEV_STAT,S_1)
		SA_EX2_FG = AND('8101Z1M':DEV_STAT,S_2)

		IF (SA_EX1_FG | SA_EX2_FG) THEN   ;KER000 stop
			BEGIN				 
			DIVERTER_POSITION_FLAG = 1
			TIMERCLR SEARCH_DIV_POSITION_TMR
			TIMERON SEARCH_DIV_POSITION_TMR
			END
		END


	IF (SEARCH_DIV_POSITION_TMR > MAX_SRCH_TIME) THEN 	;Diverter not in position
			BEGIN
			TIMEROFF SEARCH_DIV_POSITION_TMR
			GOSUB C8101Z1M		;stop the rotary diverter
			DIVERTER_POSITION_FLAG = 0	;reset flag
			SA_2_MESSAGE = "DIVERTER POSITIONING TIMEOUT"
			PRINT PRI_ADI, "%p",SA_MESSAGE 
			WAIT 5  
			RETCLR
			GOTO FAIL ;KER000 was GU1CD
			END

	SA_EX1_FG = AND('8101Z1M':DEV_STAT,S_1)          ;ROTARY diverter in reverse
	SA_EX2_FG = AND('8101Z1M':DEV_STAT,S_2)		;ROTARY diverter in forward

	IF (SA_EX1_FG | SA_EX2_FG) THEN	
		BEGIN
		GOTO CKSILOSW
		END

	SA_EX1_FG = AND('8101Z1M':DEV_STAT,S_0)	;rotary diverter off
	SA_EX2_FG = AND('8101Z1M':DEV_STAT,S_4)	;rotary diverter inlk
	SA_EX3_FG = (READY_SEAL)			;sealed or ready for seal

	IF ((SA_EX1_FG | SA_EX2_FG) & (SA_EX3_FG)) THEN	;diverter off and ready seal set
		BEGIN
		WAIT 5
		SA_MESSAGE = ""
		LAMP GUSA_ADI,GUSA_ALARM,GREEN
	   ;seal diverter
;KER000 new mdv with standard intlk T-bit
;	   IF (AND('8101Z1DS':DEV_DFLG,F_0) | !AND('8101Z1DS':DEV_TMP1,T_29)) THEN
		IF (AND(GU_DIV_SEAL:DEV_DFLG,F_0) | !AND(GU_DIV_SEAL:DEV_TMP1,T_30)) THEN
			GOTO Z1DSFLT
		IF AND(GU_DIV_SEAL:DEV_STAT,S_1) THEN
			GOTO Z1DSOK
		IF !AND(GU_DIV_SEAL:DEV_MODE,M_0) THEN
			BEGIN
			SA_2_MESSAGE = "DIV SEAL NOT IN AUTO"
			PRINT PRI_ADI, "%p",SA_2_MESSAGE
			RETCLR					    	
			GOTO FAIL
			END                                       
;KER000  new mdv with open/sealed inputs
;    '8101Z1DS':DEV_TMP1 = OR('8101Z1DS':DEV_TMP1,T_26)
		GOSUB O8101Z1DS	;seal the seal
		WAITUNTIL (AND(GU_DIV_SEAL:DEV_STAT,S_1) | AND(GU_DIV_SEAL:DEV_DFLG,F_0)) COUNT 60,Z1DSFLT
		IF AND(GU_DIV_SEAL:DEV_DFLG,F_0)  THEN
			BEGIN
;KER000 new mdb with open/sealed inputs
;	      '8101Z1DS':DEV_TMP1 = AND('8101Z1DS':DEV_TMP1,NOT(T_26))
;KER000			GOSUB C8101Z1DS
                     READY_UNLOAD = 0		
Z1DSFLT:      		SA_2_MESSAGE = "8101Z1DS FAILED TO SEAL"
			PRINT PRI_ADI, "%p",SA_2_MESSAGE
			RETCLR
			GOTO FAIL
			END
Z1DSOK:
		READY_UNLOAD = 1		;proceed to starting unloading step
		WAIT 1
		TIMEROFF SEARCH_DIV_POSITION_TMR
		TIMERCLR SEARCH_DIV_POSITION_TMR   
		END
 

	RETURN

 
;===============================================================================
;		CHECK IF MORE THAN ONE SWITCH IS MADE
;===============================================================================

CHECKSWITCHES:

;KER000	; Check diverter position               ;VCM007 START
;        ; switches for more than one made
;        M8 =  AND('MSILOSW':DGR_VAL,B_0)
;        M7 =  AND('MSILOSW':DGR_VAL,B_1)
;        M6 =  AND('MSILOSW':DGR_VAL,B_2)
;        M5 =  AND('MSILOSW':DGR_VAL,B_3)
;        M4 =  AND('MSILOSW':DGR_VAL,B_4)
;        M3 =  AND('MSILOSW':DGR_VAL,B_5)
;        M2 =  AND('MSILOSW':DGR_VAL,B_6)
;        M1 =  AND('MSILOSW':DGR_VAL,B_7)
;
;        EXPR1 = (M1 & (M2 | M3 | M4 | M5 | M6 | M7 | M8))
;        EXPR1 = EXPR1 | (M2 & (M1 | M3 | M4 | M5 | M6 | M7 | M8))
;        EXPR1 = EXPR1 | (M3 & (M1 | M2 | M4 | M5 | M6 | M7 | M8))
;        EXPR1 = EXPR1 | (M4 & (M1 | M2 | M3 | M5 | M6 | M7 | M8))
;        EXPR1 = EXPR1 | (M5 & (M1 | M2 | M3 | M4 | M6 | M7 | M8))
;        EXPR1 = EXPR1 | (M6 & (M1 | M2 | M3 | M4 | M5 | M7 | M8))
;        EXPR1 = EXPR1 | (M7 & (M1 | M2 | M3 | M4 | M5 | M6 | M8))
;        EXPR1 = EXPR1 | (M8 & (M1 | M2 | M3 | M4 | M5 | M6 | M7))
;        IF EXPR1 THEN 
;	   BEGIN
;           SA_MSG = "CHECK DIVERTER ARM SWITCHES"
;	   GOTO FAIL                          ;VCM007 END
;	   END

	; Check diverter position               ;KER000 added grits switches
      ; switches for more than one made
	WAIT 2
	
	M7 = AND('8101ILS2':DEV_STAT,S_1)
	M8 = AND('8101ILS1':DEV_STAT,S_1)
	M6 = AND('8101ILS12':DEV_STAT,S_1)
	M5 = AND('8101ILS11':DEV_STAT,S_1)
	M4 = AND('8101ILS10':DEV_STAT,S_1)
	M3 = AND('8101ILS9':DEV_STAT,S_1)
	M2 = AND('8101ILS8':DEV_STAT,S_1)
	M1 = AND('8101ILS7':DEV_STAT,S_1)
	G1 = AND('8101ILS3':DEV_STAT,S_1)			
	G2 = AND('8101ILS4':DEV_STAT,S_1)
	G3 = AND('8101ILS5':DEV_STAT,S_1)
	G4 = AND('8101ILS6':DEV_STAT,S_1)

	SA_EX1_FG = (M1 & (M2 | M3 | M4 | M5 | M6 | M7 | M8 | G1 | G2 | G3 | G4))
	SA_EX1_FG = SA_EX1_FG | (M2 & (M1 | M3 | M4 | M5 | M6 | M7 | M8 | G1 | G2 | G3 | G4))
	SA_EX1_FG = SA_EX1_FG | (M3 & (M1 | M2 | M4 | M5 | M6 | M7 | M8 | G1 | G2 | G3 | G4))
	SA_EX1_FG = SA_EX1_FG | (M4 & (M1 | M2 | M3 | M5 | M6 | M7 | M8 | G1 | G2 | G3 | G4))
	SA_EX1_FG = SA_EX1_FG | (M5 & (M1 | M2 | M3 | M4 | M6 | M7 | M8 | G1 | G2 | G3 | G4))
	SA_EX1_FG = SA_EX1_FG | (M6 & (M1 | M2 | M3 | M4 | M5 | M7 | M8 | G1 | G2 | G3 | G4))
	SA_EX1_FG = SA_EX1_FG | (M7 & (M1 | M2 | M3 | M4 | M5 | M6 | M8 | G1 | G2 | G3 | G4))
	SA_EX1_FG = SA_EX1_FG | (M8 & (M1 | M2 | M3 | M4 | M5 | M6 | M7 | G1 | G2 | G3 | G4))
	SA_EX1_FG = SA_EX1_FG | (G1 & (M1 | M2 | M3 | M4 | M5 | M6 | M7 | G2 | G3 | G4))
	SA_EX1_FG = SA_EX1_FG | (G2 & (M1 | M2 | M3 | M4 | M5 | M6 | M7 | G1 | G3 | G4))
	SA_EX1_FG = SA_EX1_FG | (G3 & (M1 | M2 | M3 | M4 | M5 | M6 | M7 | G1 | G2 | G4))
	SA_EX1_FG = SA_EX1_FG | (G4 & (M1 | M2 | M3 | M4 | M5 | M6 | M7 | G1 | G2 | G3))

	IF (SA_EX1_FG) THEN 
		BEGIN
		SA_2_MESSAGE = "CHECK DIVERTER ARM SWITCHES"
		PRINT PRI_ADI, "%p",SA_MESSAGE
		RETCLR
		GOTO FAIL                          
		END

	RETURN
           		                
;ajw001 - begin
;===============================================================================
; 	CHECK SILO DUST COLLECTOR PRESSURES
;===============================================================================
DUSTALARMS:
;New EPA requirements demand that pressures be monitored at points wheere dust can be 
;discharged into the environment.  If the system (receiver, dust collector) is running
;and the pressure is too high, it is an indication that the dust bag is clogged.  If,
;on the other hand, the system is running and the pressure is too low, it is an indication 
;that the bag may no longer be in place at all or it could be damaged.  Therefore, each alarm
;must be posted and acknowledged.


;Monitor the silo dust collector

	IF MSG_ACK_CMD THEN 	 ;mrp001
		BEGIN
      SA_3_MESSAGE =""
		SA_4_MESSAGE =""
		SA_5_MESSAGE =""
      MSG_ACK_CMD = 0    ;JMS002 
		SILO_DUST_COLL_LO_DP_POST_FG = 0		;JMS002
		SILO_DUST_COLL_HI_DP_POST_FG = 0    ;JMS002
		END
		

       ;Silo dust collector high DP
;JMS002        SUS_COND_FG = (SILO_DUST_COLLECT_PRESS:AI_MEAS > SILO_DUST_COLL_HI_DP)
   IF (SILO_DUST_COLLECT_PRESS:AI_MEAS) > (SILO_DUST_COLL_HI_DP) THEN			 ;JMS002  																							 ;JMS002
      TIMERON SILO_DUST_COLL_HI_DP_TMR                                         ;JMS002
   ;Post message
   IF (SILO_DUST_COLL_HI_DP_TMR) > (SILO_DUST_COLL_HI_DP_TIME)&!(SILO_DUST_COLL_HI_DP_POST_FG) THEN  ;JMS002
		BEGIN                                                                                          ;JMS002
      SA_3_MESSAGE = "NOTIFY TEAM MANAGER"
		SA_4_MESSAGE = "SILO DUST COLL HIGH DP"                                                        ;JMS002
		SA_5_MESSAGE = "REPLACE BAG AND ACKNOWLEDGE"                                                   ;JMS002
		PRINT LOG_ADI, "OPERATOR ASKED TO REPLACE SILO DUST COLL BAG FOR HIGH DP"                      ;JMS002
		SILO_DUST_COLL_HI_DP_POST_FG = 1                                                               ;JMS002
		END                                                                                            ;JMS002
	;Clear message                                                                                     ;JMS002
   IF (SILO_DUST_COLLECT_PRESS:AI_MEAS) < (SILO_DUST_COLL_HI_DP) THEN			                       ;JMS002  																							 ;JMS002
      BEGIN                                                                                          ;JMS002
      TIMEROFF SILO_DUST_COLL_HI_DP_TMR                                                              ;JMS002
      TIMERCLR SILO_DUST_COLL_HI_DP_TMR                                                              ;JMS002
		SILO_DUST_COLL_HI_DP_POST_FG = 0                                                               ;JMS002
		END                                                                                            ;JMS002

;JMS002	SUS_COND_TIME = SILO_DUST_COLL_HI_DP_TIME
;JMS002	ASSIGN SUS_COND_PTR = SILO_DUST_COLL_HI_DP_TMR
;JMS002	GOSUB SUSCOND                                                   

	;Post message
;JMS002	IF !SILO_DUST_COLL_HI_DP_POST_FG & SUS_COND_FG & (STRLEN(SA_4_MESSAGE) < 2) THEN
;JMS002		BEGIN
;JMS002		SA_4_MESSAGE = "SILO DUST COLL HIGH DP"
;JMS002		SA_5_MESSAGE = "REPLACE BAG AND ACKNOWLEDGE"
;JMS002		PRINT LOG_ADI, "OPERATOR ASKED TO REPLACE SILO DUST COLL BAG FOR HIGH DP"
;JMS002		SILO_DUST_COLL_HI_DP_POST_FG = 1
;JMS002		END

;JMS002	;Post message
;JMS002	IF SILO_DUST_COLL_HI_DP_POST_FG & (STRLEN(SA_4_MESSAGE) < 2) & !SILO_DUST_COLL_HI_DP_ACK_FG THEN
;JMS002		BEGIN
;JMS002		PRINT LOG_ADI, "OPERATOR ACKED REPLACEMENT OF SILO DUST COLL BAG FOR HIGH DP"
;JMS002		SILO_DUST_COLL_HI_DP_ACK_FG = 1
;JMS002		END

	;Silo dust collector low DP
   IF (SILO_DUST_COLLECT_PRESS:AI_MEAS < SILO_DUST_COLL_LO_DP) THEN			 ;JMS002  																							 ;JMS002
      TIMERON SILO_DUST_COLL_LO_DP_TMR                                      ;JMS002

	;Post message
   IF (SILO_DUST_COLL_LO_DP_TMR) > (SILO_DUST_COLL_LO_DP_TIME)&!(SILO_DUST_COLL_LO_DP_POST_FG) THEN   ;JMS002
		BEGIN                                                                                           ;JMS002
      SA_3_MESSAGE = "NOTIFY TEAM MANAGER"
		SA_4_MESSAGE = "SILO DUST COLL LOW DP. CHECK"                                                   ;JMS002
		SA_5_MESSAGE = "FOR DAMAGED BAG & ACKNOWLEDGE"                                                  ;JMS002
		PRINT LOG_ADI, "OPERATOR ASKED TO CHECK SILO DUST COLL BAG FOR LOW DP"                          ;JMS002
		SILO_DUST_COLL_LO_DP_POST_FG = 1                                                                ;JMS002
		END                                                                                             ;JMS002
   ;Clear message																													;JMS002
   IF (SILO_DUST_COLLECT_PRESS:AI_MEAS) > (SILO_DUST_COLL_LO_DP) THEN			                        ;JMS002  																							 ;JMS002
		BEGIN                                                                                           ;JMS002
		TIMEROFF SILO_DUST_COLL_LO_DP_TMR                                                               ;JMS002
		TIMERCLR SILO_DUST_COLL_LO_DP_TMR                                                               ;JMS002
		SILO_DUST_COLL_LO_DP_POST_FG = 0                                                                ;JMS002
      END                                                                                             ;JMS002

	;Silo dust collector low DP
;JMS002        SUS_COND_FG = (SILO_DUST_COLLECT_PRESS:AI_MEAS < SILO_DUST_COLL_LO_DP) & AND(GU_SILO_DUST_FAN:DEV_STAT, S_1)
;JMS002	SUS_COND_TIME = SILO_DUST_COLL_LO_DP_TIME
;JMS002	ASSIGN SUS_COND_PTR = SILO_DUST_COLL_LO_DP_TMR
;JMS002	GOSUB SUSCOND                                                   

	;Post message
;JMS002	IF !SILO_DUST_COLL_LO_DP_POST_FG & SUS_COND_FG & (STRLEN(SA_4_MESSAGE) < 2) THEN
;JMS002		BEGIN
;JMS002		SA_4_MESSAGE = "SILO DUST COLL LOW DP. CHECK"
;JMS002		SA_5_MESSAGE = "FOR DAMAGED BAG & ACKNOWLEDGE"
;JMS002		PRINT LOG_ADI, "OPERATOR ASKED TO CHECK SILO DUST COLL BAG FOR LOW DP"
;JMS002		SILO_DUST_COLL_LO_DP_POST_FG = 1
;JMS002		END

	;Post message
;JMS002	IF SILO_DUST_COLL_LO_DP_POST_FG & (STRLEN(SA_4_MESSAGE) < 2) & !SILO_DUST_COLL_LO_DP_ACK_FG THEN
;JMS002		BEGIN
;JMS002		PRINT LOG_ADI, "OPERATOR ACKED ALARM OF SILO DUST COLL BAG FOR LOW DP"
;JMS002		SILO_DUST_COLL_LO_DP_ACK_FG = 1
;JMS002		END

	IF (UNLOAD_TMR > 5) & (PT41_PRINT_FG = 0) THEN  ;VCM014
		BEGIN
		PRINT LOG_ADI, "GRAIN UNLOADING, Silo Dust Collector PT41 DP = %2.1f", '8101PT41':AI_MEAS				;pbh001
		PRINT LOG_ADI, "GRAIN UNLOADING, Railpit Dust Collect PT81 DP = %2.1f", '8101PT81':AI_MEAS				;JMS003
		PT41_PRINT_FG = 1
		END

	RETURN

;ajw001 - end

 
;===============================================================================
;		O P E N      D E V I C E      S U B R O U T I N E   #1
;===============================================================================

       ;This subroutine will attempt to open any device that it is    
       ;commanded to. The subroutine will check for four things:
       ;    if the device has been faulted ($f0)  
       ;    if the device has been interlocked ($s4)
       ;    if the device is already open ($s1)
       ;    if the device is in manual ($m0) it will go to fail
       ;                                                                      

OPENDEV:
	; if the fault bit is set or the interlock bit is set           
	; then send the program to estop                                
	  IF (AND(DEV_PTR:DEV_DFLG,F_0) | AND(DEV_PTR:DEV_STAT,S_4)) THEN
		GOTO FLTOPN

	; if device is already opened                      
	; then return to the program          
	  IF AND(DEV_PTR:DEV_STAT,S_1) THEN
		GOTO OUTOPN

	; if device is not in auto, then send the program to fail         
	  IF !AND(DEV_PTR:DEV_MODE,M_0) THEN
		BEGIN
		SA_2_MESSAGE = "DEVICE NOT IN AUTO"
		PRINT PRI_ADI, "%p",SA_MESSAGE
		RETCLR
		GOTO FAIL
		END                                       

	; open device and waituntil either device opens or faults         
	  DEV_PTR:DEV_TMP1 = OR(DEV_PTR:DEV_TMP1,T_26)   
	  WAITUNTIL (AND(DEV_PTR:DEV_STAT,S_1) | AND(DEV_PTR:DEV_DFLG,F_0)) COUNT 60,FLTOPN

	; if device is faulted              
	  IF AND(DEV_PTR:DEV_DFLG,F_0)  THEN
		BEGIN         
;KAN003	      DEV_PTR:DEV_TMP1 = AND(DEV_PTR:DEV_TMP1,NOT(T_26))
FLTOPN:       SA_2_MESSAGE = FAIL_MSG	        ; display reason for failure
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		RETCLR			; do not return to previous state
		GOTO GU5
		END

OUTOPN:   RETURN 

;===============================================================================
;		O P E N      D E V I C E      S U B R O U T I N E   #2
;===============================================================================

       ;This subroutine will attempt to open devices.   
       ;The subroutine will check for four things:
       ;    if the device has been faulted ($f0)  
       ;    if the device has been interlocked ($s4)
       ;    if the device is already open ($s1)
       ;    if the device is in manual ($m0)
       ;                                                                      
OPENDEV2:
	;KER000
	;DEV_PTR:DEV_TMP0 = OR(DEV_PTR:DEV_TMP0,T_3)

	; if the fault bit is set or the interlock bit is set           
	; then send the program to estop                                
	IF (AND(DEV_PTR:DEV_DFLG,F_0) | AND(DEV_PTR:DEV_STAT,S_4)) THEN
		GOTO FLTOPN2

	; if device is already opened                      
	; then return to the program          
	IF AND(DEV_PTR:DEV_STAT,S_1) THEN
		GOTO OUTOPN2

	; if device is not in auto, then put device in auto
	DEV_PTR:DEV_MODE = OR(DEV_PTR:DEV_MODE,M_0)      

	; open device and waituntil either device opens or faults         
	OPEN DEV_PTR
	WAITUNTIL (AND(DEV_PTR:DEV_STAT,S_1) | AND(DEV_PTR:DEV_DFLG,F_0)) COUNT 60,FLTOPN2

	; if device is faulted              
	IF AND(DEV_PTR:DEV_DFLG,F_0)  THEN
		BEGIN
FLTOPN2:   	SA_2_MESSAGE =  FAIL_MSG
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		;KER000
		;DEV_PTR:DEV_TMP0 = AND(DEV_PTR:DEV_TMP0,NOT(T_3))
		RETCLR			; do not return to previous state
		GOTO GU5		;go to e-stop unloading
		END
OUTOPN2:         
	RETURN                                                              



;===============================================================================
;		O P E N      D E V I C E      S U B R O U T I N E   #3
;===============================================================================

       ;This subroutine will attempt to open 8101xv51 or 8101rf4.   
       ;The subroutine will check for four things:
       ;    if the device has been faulted ($f0)  
       ;    if the device has been interlocked ($s4)
       ;    if the device is already open ($s1)
       ;    if the device is in manual ($m0)
       ;                                                                      
OPENDEV3:
	 
	DEV_PTR:DEV_TMP0 = OR(DEV_PTR:DEV_TMP0,T_3)

	; if the fault bit is set or the interlock bit is set           
	; then send the program to estop                                
	IF (AND(DEV_PTR:DEV_DFLG,F_0) | AND(DEV_PTR:DEV_STAT,S_4)) THEN
		GOTO FLTOPN3

	; if device is already opened                      
	; then return to the program          
	IF AND(DEV_PTR:DEV_STAT,S_1) THEN
		GOTO OUTOPN3

	; if device is not in auto, then put device in auto
	DEV_PTR:DEV_MODE = OR(DEV_PTR:DEV_MODE,M_0)      

	; open device and waituntil either device opens or faults         
	OPEN DEV_PTR
       WAITUNTIL (AND(DEV_PTR:DEV_STAT,S_1) | AND(DEV_PTR:DEV_DFLG,F_0)) COUNT 60,FLTOPN3

	; if device is faulted              
	IF AND(DEV_PTR:DEV_DFLG,F_0)  THEN
		BEGIN
FLTOPN3:   	SA_2_MESSAGE =  FAIL_MSG 
		PRINT PRI_ADI, "%p",SA_2_MESSAGE     
		DEV_PTR:DEV_TMP0 = AND(DEV_PTR:DEV_TMP0,NOT(T_3))
		RETCLR			; do not return to previous state
		GOTO GU5
		END
OUTOPN3:         
	RETURN 


;===============================================================================
;		M I D      D E V I C E      S U B R O U T I N E   #4
;===============================================================================

       ;This subroutine will attempt to MID command the rotary diverter    
       ;The subroutine will check for four things:
       ;    if the device has been faulted ($f0)  
       ;    if the device has been interlocked ($s4)
       ;    if the device is already open ($s1)
       ;    if the device is in manual ($m0)
       ;                                                                      
MIDDEV4:
	;KER00
	;DEV_PTR:DEV_TMP0 = OR(DEV_PTR:DEV_TMP0,T_3)

	; if the fault bit is set or the interlock bit is set           
	; then send the program to estop                                
	IF (AND(DEV_PTR:DEV_DFLG,F_0) | AND(DEV_PTR:DEV_STAT,S_4)) THEN
		GOTO FLTOPN3

	; if device is already opened                      
	; then return to the program          
	IF AND(DEV_PTR:DEV_STAT,S_2) THEN
		GOTO MIDOPN4

	; if device is not in auto, then put device in auto
	DEV_PTR:DEV_MODE = OR(DEV_PTR:DEV_MODE,M_0)      

	; open device and waituntil either device opens or faults         
	MID DEV_PTR
       WAITUNTIL (AND(DEV_PTR:DEV_STAT,S_2) | AND(DEV_PTR:DEV_DFLG,F_0)) COUNT 60,FLTOPN4

	; if device is faulted              
	IF AND(DEV_PTR:DEV_DFLG,F_0)  THEN
		BEGIN
FLTOPN4:   	SA_2_MESSAGE =  FAIL_MSG
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
		;KER000      
		;DEV_PTR:DEV_TMP0 = AND(DEV_PTR:DEV_TMP0,NOT(T_3))
		RETCLR			; do not return to previous state
		GOTO GU5
		END
MIDOPN4:         
	RETURN                                                   
                                                                              
;===============================================================================
;		C L O S E      D E V I C E      S U B R O U T I N E  #1
;===============================================================================

       ;This subroutine will attempt to close any device that it is    
       ;commanded to. This includes when the subroutine is called 
       ;when a device is closed from another subroutine.
       ;The subroutine will check for four things:
       ;    if the device has been faulted ($f0)  
       ;    if the device has been interlocked ($s4)
       ;    if the device is already closed ($s0)
       ;    if the device is in manual  ($m0)
       ;

CLOSDEV:
	; if the fault bit is set, send the program to fail
	  IF (AND(DEV_PTR:DEV_DFLG,F_0)) THEN
	      GOTO FLTCLS1

	; if the interlock bit is set, return to the program
	  IF (AND(DEV_PTR:DEV_STAT,S_4)) THEN
	      GOTO OUTCLS1

	; if device is already closed
	; then return to the program
	  IF AND(DEV_PTR:DEV_STAT,S_0) THEN 
	      GOTO OUTCLS1

	  ; if device is not in auto, send program to fail
	  IF !AND(DEV_PTR:DEV_MODE,M_0) THEN
	     BEGIN
		SA_2_MESSAGE = "DEVICE NOT IN AUTO"
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
;MLB001	     RETCLR
;MLB001	     GOTO FAIL
	     GOTO CHKFAIL
	     END                                      

	; close device and waituntil either device closes or faults
    	  DEV_PTR:DEV_TMP1 = AND(DEV_PTR:DEV_TMP1,NOT(T_26))  
          WAITUNTIL (AND(DEV_PTR:DEV_STAT,S_0) | AND(DEV_PTR:DEV_DFLG,F_0)) COUNT 60,FLTCLS1

	; if device is faulted
	  IF AND(DEV_PTR:DEV_DFLG,F_0) THEN  
	      BEGIN
;KAN003	      DEV_PTR:DEV_TMP1 = OR(DEV_PTR:DEV_TMP1,T_26)
FLTCLS1:      SA_2_MESSAGE = FAIL_MSG 	; display reason for failure
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
;MLB001
CHKFAIL:
	      IF ( FAIL_FLAG = 0) THEN  ; if we didn't get here from fail or
			BEGIN			; hold then
			RETCLR			; do not return to previous state
			RETCLR			; may need if 2 subroutines deep
       	       RETCLR			; may need if 3 subroutines deep KAN005
       	       GOTO FAIL
			END
;MLB001
	      END

OUTCLS1:   
	RETURN



;===============================================================================
;		C L O S E     D E V I C E       S U B R O U T I N E  #2
;===============================================================================

       ;This subroutine will attempt to close devices.    
       ;The subroutine will check for four things:
       ;    if the device has been faulted ($f0)  
       ;    if the device has been interlocked ($s4)
       ;    if the device is already closed ($s0)
       ;    if the device is in manual  ($m0)
       ;

CLOSDEV2:
	; if the fault bit is set, send the program to fail
	  IF (AND(DEV_PTR:DEV_DFLG,F_0)) THEN
	      GOTO FLTCLS2

	; if the interlock bit is set, return to the program
	  IF (AND(DEV_PTR:DEV_STAT,S_4)) THEN
	      GOTO OUTCLS2

	; if device is already closed
	; then return to the program
	  IF AND(DEV_PTR:DEV_STAT,S_0) THEN 
	      GOTO OUTCLS2

	  DEV_PTR:DEV_MODE = OR(DEV_PTR:DEV_MODE,M_0)            

	; close device and waituntil either device closes or faults
	  CLOSE DEV_PTR   
	  WAITUNTIL (AND(DEV_PTR:DEV_STAT,S_0) | AND(DEV_PTR:DEV_DFLG,F_0)) COUNT 60,FLTCLS3

	; if device is faulted
	  IF AND(DEV_PTR:DEV_DFLG,F_0) THEN  
		BEGIN
FLTCLS2:      SA_2_MESSAGE = FAIL_MSG 	; display reason for failure
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
;DWM002	      DEV_PTR:DEV_TMP0 = OR(DEV_PTR:DEV_TMP0,T_3)
;MLB001
	      IF ( FAIL_FLAG = 0) THEN  ; if we didn't get here from fail
	         BEGIN
	         ;RETCLR                 ; do not return to previous state
	         ;RETCLR                 ; may need if 2 subroutines deep
	         ;RETCLR                 ; may need if 3 subroutines deep KAN005
	         GOTO FAIL
	         END
;MLB001
	      END

OUTCLS2:  
	RETURN



;===============================================================================
;		C L O S E     D E V I C E       S U B R O U T I N E  #3
;===============================================================================

       ;This subroutine will attempt to close 8101RF4 or 8101XV51.    
       ;The subroutine will check for four things:
       ;    if the device has been faulted ($f0)  
       ;    if the device has been interlocked ($s4)
       ;    if the device is already closed ($s0)
       ;    if the device is in manual  ($m0)
       ;

CLOSDEV3:
	; if the fault bit is set, send the program to fail
	  IF (AND(DEV_PTR:DEV_DFLG,F_0)) THEN
	      GOTO FLTCLS3

	; if the interlock bit is set, return to the program
	  IF (AND(DEV_PTR:DEV_STAT,S_4)) THEN
	      GOTO OUTCLS3

	; if device is already closed
	; then return to the program
	  IF AND(DEV_PTR:DEV_STAT,S_0) THEN 
	      GOTO OUTCLS3

	  DEV_PTR:DEV_MODE = OR(DEV_PTR:DEV_MODE,M_0)            

	; close device and waituntil either device closes or faults
	  CLOSE DEV_PTR   
	  WAITUNTIL (AND(DEV_PTR:DEV_STAT,S_0) | AND(DEV_PTR:DEV_DFLG,F_0)) COUNT 60,FLTCLS3

	; if device is faulted
	  IF AND(DEV_PTR:DEV_DFLG,F_0) THEN  
	      BEGIN
FLTCLS3:      SA_2_MESSAGE = FAIL_MSG 	; display reason for failure
		PRINT PRI_ADI, "%p",SA_2_MESSAGE
;DWM002	      DEV_PTR:DEV_TMP0 = OR(DEV_PTR:DEV_TMP0,T_3)
;MLB001
	      IF ( FAIL_FLAG = 0) THEN  ; if we didn't get here from fail
	         BEGIN
;KER000	         RETCLR                 ; do not return to previous state
;KER000	         RETCLR                 ; may need if 2 subroutines deep
;KER000	         RETCLR                 ; may need if 3 subroutines deep KAN005
	         GOTO FAIL
	         END
;MLB001
	      END

OUTCLS3:  
	RETURN

;===============================================================================
;	EMERGENCY STOP SUBROUTINES
;===============================================================================
;
;The emergency stop subroutines are used to set the skid to flashing yellow,
;set the emergency stop status (1 or 2) and go to the estop state.
;
ESTOP1:
; adm000 begin                                               
;	LAMP GUSA_ADI,GUSA_ALARM,FLASH_YEL
	LAMP GUSA_ADI,GUSA_ALARM,YELLOW
; adm000 end
	ESTOP_TYPE = 1
;KER000       RETCLR         ;VCM002 ; do not return to previous stat
;KER000       RETCLR                 ; may need if 2 subroutines deep
;KER000	RETCLR                 ; may need if 3 subroutines deep
;KER000 these retclr were causing errors in the program, removed for now
	GOTO GU5            
;
ESTOP2:
; adm000 begin                                               
;	LAMP GUSA_ADI,GUSA_ALARM,FLASH_YEL
	LAMP GUSA_ADI,GUSA_ALARM,YELLOW
; adm000 end
	ESTOP_TYPE = 2
;KER000        RETCLR       ;VCM002   ; do not return to previous stat
;KER000        RETCLR                 ; may need if 2 subroutines deep
;KER000        RETCLR                 ; may need if 3 subroutines deep
	GOTO GU5                              

;===============================================================================
;	CLOSE DEVICE SUBROUTINES
;===============================================================================
;
;The close device subroutines are used to assign the device pointer, set the
;device fail message and call the close device subroutine.  Close device 
;subroutines are used for devices that are closed from more than one place
;in the main program.
;
C8101K4:
	ASSIGN DEV_PTR = GU_DRAG_CONVEYOR
	FAIL_MSG = "8101K4 FAILED TO STOP"
	GOSUB CLOSDEV2
	K4_RUNNING = 0		;DWM00X
	RETURN   
;
C8101RF41:
	ASSIGN DEV_PTR = GU_UNLOAD_RCVR_ARLK
	FAIL_MSG = "8101RF41 FAILED TO STOP"
	GOSUB CLOSDEV2             
	RETURN
;
C101C102:
    	ASSIGN DEV_PTR = GU_TRKHOP_DUST_FAN
	FAIL_MSG = "8101C102 FAILED TO STOP"
;KER000	GOSUB CLOSDEV
	GOSUB CLOSDEV2
	RETURN             
;
;VCM010 C101C101:
;VCM010 	ASSIGN DEV_PTR = '8101C101'
;VCM010 	FAIL_MSG = "8101C101 FAILED TO STOP"
;VCM010 	GOSUB CLOSDEV
;VCM010 	RETURN            
;
;mrp003C8101SR101:
;mrp003	ASSIGN DEV_PTR = '8101SR101'
;mrp003	FAIL_MSG = "8101SR101 FAILED TO STOP"
;mrp003	GOSUB CLOSDEV
;mrp003	RETURN             
;
C8101RF1:
	ASSIGN DEV_PTR = GU_TRKHOP_DUST_ARLK
	FAIL_MSG = "8101RF1 FAILED TO STOP"
	GOSUB CLOSDEV2
	RETURN             
;
C8101C12:
	ASSIGN DEV_PTR = GU_PRESSURE_BLOWER
	FAIL_MSG = "8101C12 FAILED TO STOP"
	GOSUB CLOSDEV2
	TURNOFF '8101TM1'						;MRP002
	TURNOFF '8101XV113'						;MRP002
	RETURN 

CDUSTVLV:
	ASSIGN DEV_PTR = SILO_DUST_VLV_PTR
	FAIL_MSG = "SILO DSTCOL VLV FAILED TO CLOS"
	GOSUB CLOSDEV3
	RETURN	     
;
C8101C33: 								;KER000
	TURNOFF GU_DUSTCOLL_AIRLOCK_PURGE_VALVE_DOT	;8101SV4	;ldk000
	ASSIGN DEV_PTR = GU_SPENT_GRAIN_DUST_BLOWER
	FAIL_MSG = "8101C33 FAILED TO STOP"
	GOSUB CLOSDEV3
	RETURN             

;
CFAN:
	ASSIGN DEV_PTR = DUSTCOLL_FAN_PTR
	FAIL_MSG = "DUST COLL FAN FAILED TO STOP"
;KER000	GOSUB CLOSDEV
	GOSUB CLOSDEV2
	RETURN             
;ldk001CBLOWER:
;ldk001	IF (DUST_COLLECTOR_USE_PLANT_AIR = 0)THEN  ;VCMO11
;ldk001		BEGIN
;ldk001		ASSIGN DEV_PTR = PRGE_BLOWR_PTR
;ldk001		FAIL_MSG = "DUST COL BLOWR FAILED TO STOP"
;ldk001		GOSUB CLOSDEV2
;ldk001		END
;ldk001	RETURN             
;
CDRIVE:	
;ldk000	ASSIGN DEV_PTR = CLNR_DRV_PTR
	FAIL_MSG = "DUST COL DRIVE FAILED TO STOP"
;KER000	GOSUB CLOSDEV
;ldk000	GOSUB CLOSDEV2
	TURNOFF GU_DUSTCOLL_PILOT_TIMER_VALVE_DOT	;8101PVT41	;ldk000
	RETURN             
;
CAIRLOCK:
	ASSIGN DEV_PTR = DUST_AIRLOCK_PTR
	FAIL_MSG = "DUST COL AIRLCK FAILED TO STOP"
;KER000	GOSUB CLOSDEV
	GOSUB CLOSDEV2
	RETURN                  
;
CRF4:
;KER000	'8101RF4':DEV_TMP0 = AND('8101RF4':DEV_TMP0,NOT(T_3))
;KER000	IF !AND('8101RF4':DEV_TMP0,T_0) & !AND('8101RF4':DEV_TMP0,T_1) THEN
;KER000		BEGIN
;KER000		IF !AND('8101RF4':DEV_TMP0,T_2) THEN        
;KER000			BEGIN    
	ASSIGN DEV_PTR = '8101RF4'
	FAIL_MSG = "8101RF4 AIRLCK FAILED TO STOP"
;KER000	      GOSUB CLOSDEV3
	GOSUB CLOSDEV2

	RETURN             		                
;              
C8101XV51:
	'8101XV51':DEV_TMP0 = AND('8101XV51':DEV_TMP0,NOT(T_3))
	IF !AND('8101XV51':DEV_TMP0,T_0) & !AND('8101XV51':DEV_TMP0,T_1) THEN
	   BEGIN
	   IF !AND('8101XV51':DEV_TMP0,T_2) THEN        
	      BEGIN    
	      ASSIGN DEV_PTR = '8101XV51'
	      FAIL_MSG = "VALVE 8101XV51 FAILED TO CLOSE"
	      GOSUB CLOSDEV3                                  
	      END
	   END                                                        
	RETURN
;KER000 start here 
C8101Z1DS:			
	ASSIGN DEV_PTR = GU_DIV_SEAL
	FAIL_MSG = "8101Z1DS FAILED TO OPEN"
	PRINT LOG_ADI,"OPEN seal routine"	;mp2
	GOSUB CLOSDEV2
	RETURN

C8101Z1M:	
	ASSIGN DEV_PTR = '8101Z1M'
	FAIL_MSG = "8101Z1M FAILED TO STOP"
	GOSUB CLOSDEV2
	RETURN

C8101DO1:
	ASSIGN DEV_PTR = '8101DO1'
	FAIL_MSG = "8101DO1 HORN FAILED TO RESET"
	GOSUB CLOSDEV2
	RETURN

	 



;===============================================================================
;	OPEN DEVICE SUBROUTINES
;===============================================================================
;
;The close device subroutines are used to assign the device pointer, set the
;device fail message and call the close device subroutine.  Close device 
;subroutines are used for devices that are closed from more than one place
;in the main program.
;
OFAN:
	ASSIGN DEV_PTR = DUSTCOLL_FAN_PTR
	FAIL_MSG = "DUST COLL FAN FAILED TO START"
	GOSUB OPENDEV2
	RETURN 

ODRIVE:	
;ldk000	ASSIGN DEV_PTR = CLNR_DRV_PTR
	FAIL_MSG = "DUST COL DRIVE FAILED TO START"
;ldk000	GOSUB OPENDEV2
	TURNON GU_DUSTCOLL_PILOT_TIMER_VALVE_DOT	;8101PVT41	;ldk000
	RETURN

OAIRLOCK:	
	ASSIGN DEV_PTR = DUST_AIRLOCK_PTR
	FAIL_MSG = "DUST COL AIRLCK FAILED TO STRT"
	GOSUB OPENDEV2 
	RETURN


O8101Z1DS:	
	ASSIGN DEV_PTR = GU_DIV_SEAL
	FAIL_MSG = "8101Z1DS FAILED TO SEAL"
	GOSUB OPENDEV2
	RETURN

O8101Z1M:	
	ASSIGN DEV_PTR = '8101Z1M'
	FAIL_MSG = "8101Z1M FAILED TO MOVE REVERSE"
	GOSUB OPENDEV2
	RETURN

M8101Z1M:	
	ASSIGN DEV_PTR = '8101Z1M'
	FAIL_MSG = "8101Z1M FAILED TO MOVE FORWARD"
	GOSUB MIDDEV4
	RETURN

O8101C12:
	ASSIGN DEV_PTR = GU_PRESSURE_BLOWER
	FAIL_MSG = "8101C12 BLOWER FAILED TO START"
	GOSUB OPENDEV2	;KER000 changed to opendev2 for newer mdv
	TURNON '8101TM1'							;MRP002
	TURNON '8101XV113'
	RETURN

O8101C33:
	TURNON GU_DUSTCOLL_AIRLOCK_PURGE_VALVE_DOT	;8101SV4	;ldk000
	ASSIGN DEV_PTR = GU_SPENT_GRAIN_DUST_BLOWER			;GU_DUST_BLOWER	;mrp001
	FAIL_MSG = "8101C33 BLOWER FAILED TO START"
	GOSUB OPENDEV3
	RETURN

O8101RF1:
	ASSIGN DEV_PTR = GU_TRKHOP_DUST_ARLK
	FAIL_MSG = "8101RF1 AIRLCK FAILED TO START"
	GOSUB OPENDEV2 
	RETURN

O8101C102:			     
	ASSIGN DEV_PTR = GU_TRKHOP_DUST_FAN
	FAIL_MSG = "8101C102 FAN FAILED TO START"
	GOSUB OPENDEV2
	RETURN

O8101RF41:
	PUTMANL '8101FC41'  ;VCM015
		IF (GRAIN_SEL_INT = CARAMALT) THEN			;
			PUTOUT '8101FC41', RF41_CRML_MALT_OUT  ;VCM015
		ELSE
			PUTOUT '8101FC41', RF41_REG_MALT_OUT

	ASSIGN DEV_PTR = GU_UNLOAD_RCVR_ARLK
	FAIL_MSG = "8101RF41 AIRLK FAILED TO START"
	GOSUB OPENDEV2
	RETURN

O8101RF4:
	ASSIGN DEV_PTR = '8101RF4'
	FAIL_MSG = "AIRLCK 8101RF4 FAILED TO START"
	GOSUB OPENDEV3
	RETURN

O8101XV71:
;ajw000       ASSIGN DEV_PTR = '8101XV71'
;ajw000       FAIL_MSG = "8101XV71 TO BLACK MALT FAILED"
;ajw000       GOSUB OPENDEV2
	RETURN

O8101K4:
   IF (K4_RUNNING = 0) THEN
	BEGIN
	ASSIGN DEV_PTR = GU_DRAG_CONVEYOR
	FAIL_MSG = "8101K4 FAILED TO START"
	GOSUB OPENDEV2
	K4_RUNNING = 1
	END
	RETURN



;KER000 STOP HERE
#include <suscond.inc>	       /* ajw001 */

	NOP
	END

